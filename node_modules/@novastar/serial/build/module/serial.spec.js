// import { Calibration, DeviceType, DisplayMode } from '@novastar/codec';
import serial, { findSendingCards } from './serial';
function itif(name, condition, fn) {
    it(name, done => {
        condition.then(s => fn(s, done), () => {
            console.warn(`[skipped]: ${name}`);
            done();
        });
    });
}
function asyncSerialMap(items, action) {
    return items.reduce((promise, value, index) => promise.then(async (res) => [...res, await action(value, index)]), Promise.resolve([]));
}
function toList(enumeration) {
    return Object.keys(enumeration)
        .filter(k => typeof enumeration[k] === 'number')
        .map(k => enumeration[k]);
}
describe('serials', () => {
    const sessionPromise = new Promise((resolve, reject) => {
        findSendingCards().then(([port]) => {
            if (port) {
                resolve(serial.open(port.path));
            }
            else {
                reject(new Error('Novastar device is not connected'));
            }
        }, reject);
    });
    /*
    itif('get model sending card', sessionPromise, async (session, done) => {
      const model = await session.getModel(DeviceType.SendingCard);
      console.log({ model });
      expect(model).toBe('MSD/MCTRL 300');
      done();
    });
    itif('get version sending card', sessionPromise, async (session, done) => {
      const version = await session.getSendingCardVersion();
      expect(version).toBe('4.7.2.0');
      done();
    });
    itif('MRV328 test', sessionPromise, async (session, done) => {
      const model = await session.getModel(DeviceType.ReceivingCard, 0, 0);
      expect(model).toBe('MRV 328');
      done();
    });
    itif('brightness', sessionPromise, async (session, done) => {
      const brightness = Math.floor(Math.random() * 256);
      await session.setBrightness(brightness, 0);
      const value = await session.getBrightness(0);
      expect(value).toBe(brightness);
      done();
    });
    itif('redundant check', sessionPromise, async (session, done) => {
      const status = await session.checkRedundantStatus();
      expect(status).toEqual([false, false, false, false]);
      done();
    });
    itif('autobrightness mode', sessionPromise, async (session, done) => {
      const modes = [true, false];
      const res = await asyncSerialMap([true, false], async value => {
        await session.setAutobrightnessMode(value);
        return session.getAutobrightnessMode();
      });
      expect(res).toEqual(modes);
      done();
    });
    itif('display mode', sessionPromise, async (session, done) => {
      const modes = toList(DisplayMode).reverse();
      const res = await asyncSerialMap(modes, async value => {
        await session.setDisplayMode(value);
        return session.getDisplayMode();
      });
      expect(res).toEqual(modes);
      done();
    });
    itif('calibration mode', sessionPromise, async (session, done) => {
      const modes: [isOn: boolean, type: Calibration][] = [
        [true, Calibration.Brightness],
        [true, Calibration.Color],
        [false, Calibration.Color],
      ];
      const res = await asyncSerialMap(modes, async ([isOn, type]) => {
        await session.setCalibrationMode(isOn, type);
        const mode = await session.getCalibrationMode();
        return [mode.isOn, mode.type];
      });
      expect(res).toEqual(modes);
      done();
    });
  */
    afterAll(() => {
        sessionPromise.then(session => session.close(), () => { });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsLnNwZWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc2VyaWFsLnNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMEVBQTBFO0FBRTFFLE9BQU8sTUFBTSxFQUFFLEVBQUUsZ0JBQWdCLEVBQWlCLE1BQU0sVUFBVSxDQUFDO0FBSW5FLFNBQVMsSUFBSSxDQUFJLElBQVksRUFBRSxTQUFxQixFQUFFLEVBQXFDO0lBQ3pGLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUU7UUFDZCxTQUFTLENBQUMsSUFBSSxDQUNaLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFDaEIsR0FBRyxFQUFFO1lBQ0gsT0FBTyxDQUFDLElBQUksQ0FBQyxjQUFjLElBQUksRUFBRSxDQUFDLENBQUM7WUFDbkMsSUFBSSxFQUFFLENBQUM7UUFDVCxDQUFDLENBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQVMsY0FBYyxDQUNyQixLQUFtQixFQUNuQixNQUErQztJQUUvQyxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQ2pCLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFDLEdBQUcsRUFBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxNQUFNLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUMxRixPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUNwQixDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsTUFBTSxDQUFJLFdBQWM7SUFDL0IsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztTQUM1QixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLFdBQVcsQ0FBQyxDQUFZLENBQUMsS0FBSyxRQUFRLENBQUM7U0FDMUQsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQVksQ0FBQyxDQUFDLENBQUM7QUFDekMsQ0FBQztBQUVELFFBQVEsQ0FBQyxTQUFTLEVBQUUsR0FBRyxFQUFFO0lBQ3ZCLE1BQU0sY0FBYyxHQUFHLElBQUksT0FBTyxDQUFnQixDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUNwRSxnQkFBZ0IsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNqQyxJQUFJLElBQUksRUFBRTtnQkFDUixPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUNqQztpQkFBTTtnQkFDTCxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQyxDQUFDO2FBQ3ZEO1FBQ0gsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2IsQ0FBQyxDQUFDLENBQUM7SUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTZEQTtJQUNBLFFBQVEsQ0FBQyxHQUFHLEVBQUU7UUFDWixjQUFjLENBQUMsSUFBSSxDQUNqQixPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFDMUIsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUNULENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIn0=