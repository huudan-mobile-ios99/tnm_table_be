"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerialBinding = exports.findSendingCards = exports.clearKnownDevices = exports.removeKnownDevice = exports.addKnownDevice = exports.getKnownDevices = void 0;
const codec_1 = require("@novastar/codec");
const conf_1 = __importDefault(require("conf"));
const debug_1 = __importDefault(require("debug"));
const serialport_1 = require("serialport");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const debug = (0, debug_1.default)('novastar:serial');
const schema = {
    knownDevices: {
        type: 'array',
        items: {
            type: 'array',
            items: {
                type: 'string',
                pattern: '[0-9a-fA-F]+',
            },
            minItems: 2,
        },
        default: [['10c4', 'ea60']],
    },
};
const config = new conf_1.default({ schema });
/**
 * Get all known devices
 */
const getKnownDevices = () => config.get('knownDevices');
exports.getKnownDevices = getKnownDevices;
debug(`known devices: ${(0, exports.getKnownDevices)()
    .map(([VID, PID]) => `${VID}/${PID}`)
    .join(';')}`);
/**
 * Add a new known device type
 * @param vendorId
 * @param productId
 */
const addKnownDevice = (vendorId, productId) => {
    const VID = typeof vendorId === 'number' ? vendorId.toString(16) : vendorId;
    const PID = typeof productId === 'number' ? productId.toString(16) : productId;
    const devs = (0, exports.getKnownDevices)();
    if (devs.findIndex(([vid, pid]) => vid === VID && pid === PID) === -1) {
        config.set('knownDevices', [...devs, [VID, PID]]);
    }
    return (0, exports.getKnownDevices)();
};
exports.addKnownDevice = addKnownDevice;
/**
 * Remove known device by VID,PID
 * @param vendorId
 * @param productId
 */
const removeKnownDevice = (vendorId, productId) => {
    const VID = typeof vendorId === 'number' ? vendorId.toString(16) : vendorId;
    const PID = typeof productId === 'number' ? productId.toString(16) : productId;
    config.set('knownDevice', (0, exports.getKnownDevices)().filter(([vid, pid]) => vid !== VID || pid !== PID));
    return (0, exports.getKnownDevices)();
};
exports.removeKnownDevice = removeKnownDevice;
/**
 * Clear all known devices
 */
const clearKnownDevices = () => config.set('knownDevices', []);
exports.clearKnownDevices = clearKnownDevices;
const isNovastarUSBDevice = (known = (0, exports.getKnownDevices)()) => (portInfo) => known.findIndex(([vendorId, productId]) => vendorId.toLowerCase() === portInfo.vendorId?.toLowerCase() &&
    productId.toLowerCase() === portInfo.productId?.toLowerCase()) !== -1;
/**
 * Finding serial devices
 * @param known
 * @returns {Promise<PortInfo[]>} - paths to found devices
 */
const findSendingCards = async (known = []) => {
    const ports = await serialport_1.SerialPort.list();
    return ports.filter(isNovastarUSBDevice((0, exports.getKnownDevices)().concat(known)));
};
exports.findSendingCards = findSendingCards;
/**
 * @internal For documentation purposes only. Use singleton instance exported as default
 */
class SerialBinding extends tiny_typed_emitter_1.TypedEmitter {
    constructor() {
        super(...arguments);
        this.sessions = {};
    }
    /**
     * Connect to a serial device and open a serial session
     * @param opts
     */
    open(opts) {
        return new Promise((resolve, reject) => {
            const { path } = opts;
            let session = this.sessions[path];
            if (session) {
                resolve(session);
            }
            else {
                const port = new serialport_1.SerialPort({ ...opts, parity: 'none' }, err => {
                    if (err)
                        reject(err);
                    else {
                        const connection = new codec_1.Connection(port);
                        session = new codec_1.Session(connection);
                        this.sessions[path] = session;
                        connection.once('close', () => this.close(path));
                        resolve(session);
                        this.emit('open', path);
                    }
                });
                port.once('close', () => this.close(path));
            }
        });
    }
    /**
     * Close serial session
     * @param path
     */
    close(path) {
        const session = this.sessions[path];
        if (session) {
            delete this.sessions[path];
            session.close();
            const { connection } = session;
            const { stream: serial } = connection;
            if (serial.isOpen)
                serial.close();
            this.emit('close', path);
        }
        return session !== undefined;
    }
    /**
     * Get all serial sessions
     */
    getSessions() {
        return Object.values(this.sessions);
    }
    /**
     * Close all serial sessions
     */
    release() {
        this.getSessions().forEach(session => session.close());
    }
}
exports.SerialBinding = SerialBinding;
/**
 * Binding to work with serial devices
 */
const serial = new SerialBinding();
const release = () => serial.release();
process.on('SIGINT', release);
process.on('SIGTERM', release);
exports.default = serial;
//# sourceMappingURL=serial.js.map