"use strict";
// import { Calibration, DeviceType, DisplayMode } from '@novastar/codec';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const serial_1 = __importStar(require("./serial"));
function itif(name, condition, fn) {
    it(name, done => {
        condition.then(s => fn(s, done), () => {
            console.warn(`[skipped]: ${name}`);
            done();
        });
    });
}
function asyncSerialMap(items, action) {
    return items.reduce((promise, value, index) => promise.then(async (res) => [...res, await action(value, index)]), Promise.resolve([]));
}
function toList(enumeration) {
    return Object.keys(enumeration)
        .filter(k => typeof enumeration[k] === 'number')
        .map(k => enumeration[k]);
}
describe('serials', () => {
    const sessionPromise = new Promise((resolve, reject) => {
        (0, serial_1.findSendingCards)().then(([port]) => {
            if (port) {
                resolve(serial_1.default.open(port.path));
            }
            else {
                reject(new Error('Novastar device is not connected'));
            }
        }, reject);
    });
    /*
    itif('get model sending card', sessionPromise, async (session, done) => {
      const model = await session.getModel(DeviceType.SendingCard);
      console.log({ model });
      expect(model).toBe('MSD/MCTRL 300');
      done();
    });
    itif('get version sending card', sessionPromise, async (session, done) => {
      const version = await session.getSendingCardVersion();
      expect(version).toBe('4.7.2.0');
      done();
    });
    itif('MRV328 test', sessionPromise, async (session, done) => {
      const model = await session.getModel(DeviceType.ReceivingCard, 0, 0);
      expect(model).toBe('MRV 328');
      done();
    });
    itif('brightness', sessionPromise, async (session, done) => {
      const brightness = Math.floor(Math.random() * 256);
      await session.setBrightness(brightness, 0);
      const value = await session.getBrightness(0);
      expect(value).toBe(brightness);
      done();
    });
    itif('redundant check', sessionPromise, async (session, done) => {
      const status = await session.checkRedundantStatus();
      expect(status).toEqual([false, false, false, false]);
      done();
    });
    itif('autobrightness mode', sessionPromise, async (session, done) => {
      const modes = [true, false];
      const res = await asyncSerialMap([true, false], async value => {
        await session.setAutobrightnessMode(value);
        return session.getAutobrightnessMode();
      });
      expect(res).toEqual(modes);
      done();
    });
    itif('display mode', sessionPromise, async (session, done) => {
      const modes = toList(DisplayMode).reverse();
      const res = await asyncSerialMap(modes, async value => {
        await session.setDisplayMode(value);
        return session.getDisplayMode();
      });
      expect(res).toEqual(modes);
      done();
    });
    itif('calibration mode', sessionPromise, async (session, done) => {
      const modes: [isOn: boolean, type: Calibration][] = [
        [true, Calibration.Brightness],
        [true, Calibration.Color],
        [false, Calibration.Color],
      ];
      const res = await asyncSerialMap(modes, async ([isOn, type]) => {
        await session.setCalibrationMode(isOn, type);
        const mode = await session.getCalibrationMode();
        return [mode.isOn, mode.type];
      });
      expect(res).toEqual(modes);
      done();
    });
  */
    afterAll(() => {
        sessionPromise.then(session => session.close(), () => { });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsLnNwZWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc2VyaWFsLnNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLDBFQUEwRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTFFLG1EQUFtRTtBQUluRSxTQUFTLElBQUksQ0FBSSxJQUFZLEVBQUUsU0FBcUIsRUFBRSxFQUFxQztJQUN6RixFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFO1FBQ2QsU0FBUyxDQUFDLElBQUksQ0FDWixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQ2hCLEdBQUcsRUFBRTtZQUNILE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ25DLElBQUksRUFBRSxDQUFDO1FBQ1QsQ0FBQyxDQUNGLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FDckIsS0FBbUIsRUFDbkIsTUFBK0M7SUFFL0MsT0FBTyxLQUFLLENBQUMsTUFBTSxDQUNqQixDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBQyxHQUFHLEVBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsTUFBTSxNQUFNLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFDMUYsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FDcEIsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLE1BQU0sQ0FBSSxXQUFjO0lBQy9CLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7U0FDNUIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxXQUFXLENBQUMsQ0FBWSxDQUFDLEtBQUssUUFBUSxDQUFDO1NBQzFELEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFZLENBQUMsQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRCxRQUFRLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRTtJQUN2QixNQUFNLGNBQWMsR0FBRyxJQUFJLE9BQU8sQ0FBZ0IsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7UUFDcEUsSUFBQSx5QkFBZ0IsR0FBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNqQyxJQUFJLElBQUksRUFBRTtnQkFDUixPQUFPLENBQUMsZ0JBQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDakM7aUJBQU07Z0JBQ0wsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLGtDQUFrQyxDQUFDLENBQUMsQ0FBQzthQUN2RDtRQUNILENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNiLENBQUMsQ0FBQyxDQUFDO0lBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE2REE7SUFDQSxRQUFRLENBQUMsR0FBRyxFQUFFO1FBQ1osY0FBYyxDQUFDLElBQUksQ0FDakIsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQzFCLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FDVCxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyJ9