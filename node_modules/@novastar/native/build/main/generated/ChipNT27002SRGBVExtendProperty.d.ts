import * as t from 'io-ts';
import { ChipNT27002SExtendProperty } from './ChipNT27002SExtendProperty';
export declare const ChipNT27002SRGBVExtendPropertyBase: t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
    REG_LENGTH: t.Type<number, number, unknown>;
}>, t.PartialC<{
    RedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipNT27002SExtendProperty">;
    }>]>;
    GreenProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipNT27002SExtendProperty">;
    }>]>;
    BlueProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipNT27002SExtendProperty">;
    }>]>;
    VRedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipNT27002SExtendProperty">;
    }>]>;
    IsUseNewModule: t.Type<boolean, boolean, unknown>;
    ChipLibVersion: t.Type<number, number, unknown>;
    ScanType: t.Type<number, number, unknown>;
    IsAdvancedMode: t.Type<boolean, boolean, unknown>;
    MyRedGain: t.Type<number, number, unknown>;
    RedRangeGain: t.Type<number, number, unknown>;
    MyGreenGain: t.Type<number, number, unknown>;
    GreenRangeGain: t.Type<number, number, unknown>;
    MyBlueGain: t.Type<number, number, unknown>;
    BlueRangeGain: t.Type<number, number, unknown>;
    GraySteps: t.Type<number, number, unknown>;
    GetTrueGraySteps: t.Type<number, number, unknown>;
    NO_GCLK: t.Type<number, number, unknown>;
    F_gclk: t.Type<number, number, unknown>;
    FrameStartTime: t.Type<number, number, unknown>;
    ScanBetweenTime: t.Type<number, number, unknown>;
    ShadowEliminationTime: t.Type<number, number, unknown>;
    PrechargeTime: t.Type<number, number, unknown>;
    ScanShadowEliminationTime: t.Type<number, number, unknown>;
    ScanOpeningDelayTime: t.Type<number, number, unknown>;
    ScanCloseingDelayTime: t.Type<number, number, unknown>;
    ScanShadowEliminationVoltage: t.Type<number, number, unknown>;
    ShadowEliminationVoltageR: t.Type<number, number, unknown>;
    ShadowEliminationVoltageG: t.Type<number, number, unknown>;
    ShadowEliminationVoltageB: t.Type<number, number, unknown>;
    PulseWidthCompensationR: t.Type<number, number, unknown>;
    PulseWidthCompensationG: t.Type<number, number, unknown>;
    PulseWidthCompensationB: t.Type<number, number, unknown>;
    PrechargeVoltagR: t.Type<number, number, unknown>;
    PrechargeVoltagG: t.Type<number, number, unknown>;
    PrechargeVoltagB: t.Type<number, number, unknown>;
    ColorTemperature1R: t.Type<number, number, unknown>;
    ColorTemperature1G: t.Type<number, number, unknown>;
    ColorTemperature1B: t.Type<number, number, unknown>;
    ColorTemperature2R: t.Type<number, number, unknown>;
    ColorTemperature2G: t.Type<number, number, unknown>;
    ColorTemperature2B: t.Type<number, number, unknown>;
    ColorTemperature3R: t.Type<number, number, unknown>;
    ColorTemperature3G: t.Type<number, number, unknown>;
    ColorTemperature3B: t.Type<number, number, unknown>;
    AbnormalStatePattern: t.Type<number, number, unknown>;
    OpenVoltageR: t.Type<number, number, unknown>;
    OpenVoltageG: t.Type<number, number, unknown>;
    OpenVoltageB: t.Type<number, number, unknown>;
    DICOpenDateReplication: t.Type<boolean, boolean, unknown>;
    DICOpenDark: t.Type<boolean, boolean, unknown>;
    SavingMode: t.Type<boolean, boolean, unknown>;
    TemperatureSelevtorEn: t.Type<boolean, boolean, unknown>;
    TemperatureSelevtorLevel: t.Type<number, number, unknown>;
    ChannelCloseMode: t.Type<number, number, unknown>;
    FileNumber: t.Type<number, number, unknown>;
    FirstDataLen: t.Type<number, number, unknown>;
    FirstStartIndex: t.Type<number, number, unknown>;
    FirstRegisterAddr: t.Type<number, number, unknown>;
    SecondDataLen: t.Type<number, number, unknown>;
    SecondStartIndex: t.Type<number, number, unknown>;
    SecondRegisterAddr: t.Type<number, number, unknown>;
    SpecialDataLen: t.Type<number, number, unknown>;
    SpecialRegisterAddr: t.Type<number, number, unknown>;
}>]>;
/**
 * @category Codecs
 * @desc Codec for {@link ChipNT27002SRGBVExtendProperty}
 * @see Automatically generated from ../decompiled/Nova.LCT.GigabitSystem.ChipNT27002S.decompiled.cs:1039
 */
export declare const ChipNT27002SRGBVExtendProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
    REG_LENGTH: t.Type<number, number, unknown>;
}>, t.PartialC<{
    RedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipNT27002SExtendProperty">;
    }>]>;
    GreenProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipNT27002SExtendProperty">;
    }>]>;
    BlueProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipNT27002SExtendProperty">;
    }>]>;
    VRedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipNT27002SExtendProperty">;
    }>]>;
    IsUseNewModule: t.Type<boolean, boolean, unknown>;
    ChipLibVersion: t.Type<number, number, unknown>;
    ScanType: t.Type<number, number, unknown>;
    IsAdvancedMode: t.Type<boolean, boolean, unknown>;
    MyRedGain: t.Type<number, number, unknown>;
    RedRangeGain: t.Type<number, number, unknown>;
    MyGreenGain: t.Type<number, number, unknown>;
    GreenRangeGain: t.Type<number, number, unknown>;
    MyBlueGain: t.Type<number, number, unknown>;
    BlueRangeGain: t.Type<number, number, unknown>;
    GraySteps: t.Type<number, number, unknown>;
    GetTrueGraySteps: t.Type<number, number, unknown>;
    NO_GCLK: t.Type<number, number, unknown>;
    F_gclk: t.Type<number, number, unknown>;
    FrameStartTime: t.Type<number, number, unknown>;
    ScanBetweenTime: t.Type<number, number, unknown>;
    ShadowEliminationTime: t.Type<number, number, unknown>;
    PrechargeTime: t.Type<number, number, unknown>;
    ScanShadowEliminationTime: t.Type<number, number, unknown>;
    ScanOpeningDelayTime: t.Type<number, number, unknown>;
    ScanCloseingDelayTime: t.Type<number, number, unknown>;
    ScanShadowEliminationVoltage: t.Type<number, number, unknown>;
    ShadowEliminationVoltageR: t.Type<number, number, unknown>;
    ShadowEliminationVoltageG: t.Type<number, number, unknown>;
    ShadowEliminationVoltageB: t.Type<number, number, unknown>;
    PulseWidthCompensationR: t.Type<number, number, unknown>;
    PulseWidthCompensationG: t.Type<number, number, unknown>;
    PulseWidthCompensationB: t.Type<number, number, unknown>;
    PrechargeVoltagR: t.Type<number, number, unknown>;
    PrechargeVoltagG: t.Type<number, number, unknown>;
    PrechargeVoltagB: t.Type<number, number, unknown>;
    ColorTemperature1R: t.Type<number, number, unknown>;
    ColorTemperature1G: t.Type<number, number, unknown>;
    ColorTemperature1B: t.Type<number, number, unknown>;
    ColorTemperature2R: t.Type<number, number, unknown>;
    ColorTemperature2G: t.Type<number, number, unknown>;
    ColorTemperature2B: t.Type<number, number, unknown>;
    ColorTemperature3R: t.Type<number, number, unknown>;
    ColorTemperature3G: t.Type<number, number, unknown>;
    ColorTemperature3B: t.Type<number, number, unknown>;
    AbnormalStatePattern: t.Type<number, number, unknown>;
    OpenVoltageR: t.Type<number, number, unknown>;
    OpenVoltageG: t.Type<number, number, unknown>;
    OpenVoltageB: t.Type<number, number, unknown>;
    DICOpenDateReplication: t.Type<boolean, boolean, unknown>;
    DICOpenDark: t.Type<boolean, boolean, unknown>;
    SavingMode: t.Type<boolean, boolean, unknown>;
    TemperatureSelevtorEn: t.Type<boolean, boolean, unknown>;
    TemperatureSelevtorLevel: t.Type<number, number, unknown>;
    ChannelCloseMode: t.Type<number, number, unknown>;
    FileNumber: t.Type<number, number, unknown>;
    FirstDataLen: t.Type<number, number, unknown>;
    FirstStartIndex: t.Type<number, number, unknown>;
    FirstRegisterAddr: t.Type<number, number, unknown>;
    SecondDataLen: t.Type<number, number, unknown>;
    SecondStartIndex: t.Type<number, number, unknown>;
    SecondRegisterAddr: t.Type<number, number, unknown>;
    SpecialDataLen: t.Type<number, number, unknown>;
    SpecialRegisterAddr: t.Type<number, number, unknown>;
}>]>, t.PartialC<{
    '@_xsi:type': t.LiteralC<"ChipNT27002SRGBVExtendProperty">;
}>]>;
export interface ChipNT27002SRGBVExtendProperty extends t.TypeOf<typeof ChipNT27002SRGBVExtendProperty> {
    RedProperty?: ChipNT27002SExtendProperty;
    GreenProperty?: ChipNT27002SExtendProperty;
    BlueProperty?: ChipNT27002SExtendProperty;
    VRedProperty?: ChipNT27002SExtendProperty;
}
