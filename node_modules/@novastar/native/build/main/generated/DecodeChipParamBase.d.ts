import * as t from 'io-ts';
import { DecodeTypeEnum } from './DecodeType';
/**
 * @category Codecs
 * @desc Codec for interface {@link DecodeChipParamBase}
 * @see Automatically generated from ../decompiled/Nova.LCT.GigabitSystem.DataClass.decompiled.cs:18446
 */
export declare const DecodeChipParamBase: t.PartialC<{
    DecodeChipType: t.Type<DecodeTypeEnum, "Unknown" | "StaticNoCode" | "Decode138" | "DicrectCode" | "Decode595" | "LXY695x" | "Decode5953" | "Decode5958" | "SM5266" | "ICN2012WEA" | "LS9739_anode" | "LS9739_cathode" | "DecodeICN2018_ICN2019" | "LS9736_anode" | "Decode5972" | "LS9737_anode" | "LS9735_anode" | "LS2018_anode" | "LS9737_cathode" | "SM5366" | "MY7183" | "LS9736_cathode" | "TC7261" | "D7266" | "CNS3018" | "LS9737_Common" | "MBI5981" | "HX6158H" | "MBI5986" | "DP32019" | "DP32020" | "MBI5988" | "FM7239A" | "SM5368" | "FM7519" | "CFD2138S" | "RT5918", unknown>;
    IsNewDecodeType: t.Type<boolean, boolean, unknown>;
    BlankUnitNumPerScan: t.Type<number, number, unknown>;
    RowChangePoint: t.Type<number, number, unknown>;
    CtrEndPoint: t.Type<number, number, unknown>;
}>;
export interface DecodeChipParamBase extends t.TypeOf<typeof DecodeChipParamBase> {
    DecodeChipType?: DecodeTypeEnum;
}
