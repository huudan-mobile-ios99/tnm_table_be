import * as t from 'io-ts';
import { ChipSM16389ExtendProperty } from './ChipSM16389ExtendProperty';
export declare const ChipSM16389RGBVExtendPropertyBase: t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
    REG_LENGTH: t.Type<number, number, unknown>;
}>, t.PartialC<{
    RedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        EnergyPattern: t.Type<number, number, unknown>;
        LowGrayHomogeneity: t.Type<number, number, unknown>;
        CouplingOptimize2: t.Type<number, number, unknown>;
        BlankingTime1: t.Type<number, number, unknown>;
        FirstLineCompensation: t.Type<number, number, unknown>;
        LowGrayOptimize2: t.Type<number, number, unknown>;
        OpenTest: t.Type<boolean, boolean, unknown>;
        EliminateOpenCrossGrade: t.Type<number, number, unknown>;
        CouplingEnhancePattern: t.Type<boolean, boolean, unknown>;
        LowGrayOptimize1: t.Type<number, number, unknown>;
        LowGrayAcrossStripeOptimize: t.Type<number, number, unknown>;
        CouplingGrade: t.Type<number, number, unknown>;
        Gain: t.Type<number, number, unknown>;
        BlankingGrade1: t.Type<number, number, unknown>;
        FirstLineDarkCompensationGrade: t.Type<number, number, unknown>;
        BlankingOpen2: t.Type<boolean, boolean, unknown>;
        BlankingGrade2: t.Type<number, number, unknown>;
        BlankingOpen3: t.Type<boolean, boolean, unknown>;
        BlankingGrade3: t.Type<number, number, unknown>;
        CouplingOptimize1: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipSM16389ExtendProperty">;
    }>]>;
    GreenProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        EnergyPattern: t.Type<number, number, unknown>;
        LowGrayHomogeneity: t.Type<number, number, unknown>;
        CouplingOptimize2: t.Type<number, number, unknown>;
        BlankingTime1: t.Type<number, number, unknown>;
        FirstLineCompensation: t.Type<number, number, unknown>;
        LowGrayOptimize2: t.Type<number, number, unknown>;
        OpenTest: t.Type<boolean, boolean, unknown>;
        EliminateOpenCrossGrade: t.Type<number, number, unknown>;
        CouplingEnhancePattern: t.Type<boolean, boolean, unknown>;
        LowGrayOptimize1: t.Type<number, number, unknown>;
        LowGrayAcrossStripeOptimize: t.Type<number, number, unknown>;
        CouplingGrade: t.Type<number, number, unknown>;
        Gain: t.Type<number, number, unknown>;
        BlankingGrade1: t.Type<number, number, unknown>;
        FirstLineDarkCompensationGrade: t.Type<number, number, unknown>;
        BlankingOpen2: t.Type<boolean, boolean, unknown>;
        BlankingGrade2: t.Type<number, number, unknown>;
        BlankingOpen3: t.Type<boolean, boolean, unknown>;
        BlankingGrade3: t.Type<number, number, unknown>;
        CouplingOptimize1: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipSM16389ExtendProperty">;
    }>]>;
    BlueProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        EnergyPattern: t.Type<number, number, unknown>;
        LowGrayHomogeneity: t.Type<number, number, unknown>;
        CouplingOptimize2: t.Type<number, number, unknown>;
        BlankingTime1: t.Type<number, number, unknown>;
        FirstLineCompensation: t.Type<number, number, unknown>;
        LowGrayOptimize2: t.Type<number, number, unknown>;
        OpenTest: t.Type<boolean, boolean, unknown>;
        EliminateOpenCrossGrade: t.Type<number, number, unknown>;
        CouplingEnhancePattern: t.Type<boolean, boolean, unknown>;
        LowGrayOptimize1: t.Type<number, number, unknown>;
        LowGrayAcrossStripeOptimize: t.Type<number, number, unknown>;
        CouplingGrade: t.Type<number, number, unknown>;
        Gain: t.Type<number, number, unknown>;
        BlankingGrade1: t.Type<number, number, unknown>;
        FirstLineDarkCompensationGrade: t.Type<number, number, unknown>;
        BlankingOpen2: t.Type<boolean, boolean, unknown>;
        BlankingGrade2: t.Type<number, number, unknown>;
        BlankingOpen3: t.Type<boolean, boolean, unknown>;
        BlankingGrade3: t.Type<number, number, unknown>;
        CouplingOptimize1: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipSM16389ExtendProperty">;
    }>]>;
    VRedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        EnergyPattern: t.Type<number, number, unknown>;
        LowGrayHomogeneity: t.Type<number, number, unknown>;
        CouplingOptimize2: t.Type<number, number, unknown>;
        BlankingTime1: t.Type<number, number, unknown>;
        FirstLineCompensation: t.Type<number, number, unknown>;
        LowGrayOptimize2: t.Type<number, number, unknown>;
        OpenTest: t.Type<boolean, boolean, unknown>;
        EliminateOpenCrossGrade: t.Type<number, number, unknown>;
        CouplingEnhancePattern: t.Type<boolean, boolean, unknown>;
        LowGrayOptimize1: t.Type<number, number, unknown>;
        LowGrayAcrossStripeOptimize: t.Type<number, number, unknown>;
        CouplingGrade: t.Type<number, number, unknown>;
        Gain: t.Type<number, number, unknown>;
        BlankingGrade1: t.Type<number, number, unknown>;
        FirstLineDarkCompensationGrade: t.Type<number, number, unknown>;
        BlankingOpen2: t.Type<boolean, boolean, unknown>;
        BlankingGrade2: t.Type<number, number, unknown>;
        BlankingOpen3: t.Type<boolean, boolean, unknown>;
        BlankingGrade3: t.Type<number, number, unknown>;
        CouplingOptimize1: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipSM16389ExtendProperty">;
    }>]>;
    IsUseNewModule: t.Type<boolean, boolean, unknown>;
    ChipLibVersion: t.Type<number, number, unknown>;
    IsAdvancedMode: t.Type<boolean, boolean, unknown>;
    TestGain: t.Type<number, number, unknown>;
    IsErrOpen: t.Type<boolean, boolean, unknown>;
    SpecialDataLen: t.Type<number, number, unknown>;
    SpecialRegisterAddr: t.Type<number, number, unknown>;
    LittlePeriodCount: t.Type<number, number, unknown>;
    RefreshMagnificationP1: t.Type<number, number, unknown>;
    RefreshMagnificationP2: t.Type<number, number, unknown>;
    RefreshMagnificationP3: t.Type<number, number, unknown>;
    LineScanGrayScale: t.Type<number, number, unknown>;
}>]>;
/**
 * @category Codecs
 * @desc Codec for {@link ChipSM16389RGBVExtendProperty}
 * @see Automatically generated from ../decompiled/Nova.LCT.GigabitSystem.ChipSM16389.decompiled.cs:1321
 */
export declare const ChipSM16389RGBVExtendProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
    REG_LENGTH: t.Type<number, number, unknown>;
}>, t.PartialC<{
    RedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        EnergyPattern: t.Type<number, number, unknown>;
        LowGrayHomogeneity: t.Type<number, number, unknown>;
        CouplingOptimize2: t.Type<number, number, unknown>;
        BlankingTime1: t.Type<number, number, unknown>;
        FirstLineCompensation: t.Type<number, number, unknown>;
        LowGrayOptimize2: t.Type<number, number, unknown>;
        OpenTest: t.Type<boolean, boolean, unknown>;
        EliminateOpenCrossGrade: t.Type<number, number, unknown>;
        CouplingEnhancePattern: t.Type<boolean, boolean, unknown>;
        LowGrayOptimize1: t.Type<number, number, unknown>;
        LowGrayAcrossStripeOptimize: t.Type<number, number, unknown>;
        CouplingGrade: t.Type<number, number, unknown>;
        Gain: t.Type<number, number, unknown>;
        BlankingGrade1: t.Type<number, number, unknown>;
        FirstLineDarkCompensationGrade: t.Type<number, number, unknown>;
        BlankingOpen2: t.Type<boolean, boolean, unknown>;
        BlankingGrade2: t.Type<number, number, unknown>;
        BlankingOpen3: t.Type<boolean, boolean, unknown>;
        BlankingGrade3: t.Type<number, number, unknown>;
        CouplingOptimize1: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipSM16389ExtendProperty">;
    }>]>;
    GreenProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        EnergyPattern: t.Type<number, number, unknown>;
        LowGrayHomogeneity: t.Type<number, number, unknown>;
        CouplingOptimize2: t.Type<number, number, unknown>;
        BlankingTime1: t.Type<number, number, unknown>;
        FirstLineCompensation: t.Type<number, number, unknown>;
        LowGrayOptimize2: t.Type<number, number, unknown>;
        OpenTest: t.Type<boolean, boolean, unknown>;
        EliminateOpenCrossGrade: t.Type<number, number, unknown>;
        CouplingEnhancePattern: t.Type<boolean, boolean, unknown>;
        LowGrayOptimize1: t.Type<number, number, unknown>;
        LowGrayAcrossStripeOptimize: t.Type<number, number, unknown>;
        CouplingGrade: t.Type<number, number, unknown>;
        Gain: t.Type<number, number, unknown>;
        BlankingGrade1: t.Type<number, number, unknown>;
        FirstLineDarkCompensationGrade: t.Type<number, number, unknown>;
        BlankingOpen2: t.Type<boolean, boolean, unknown>;
        BlankingGrade2: t.Type<number, number, unknown>;
        BlankingOpen3: t.Type<boolean, boolean, unknown>;
        BlankingGrade3: t.Type<number, number, unknown>;
        CouplingOptimize1: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipSM16389ExtendProperty">;
    }>]>;
    BlueProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        EnergyPattern: t.Type<number, number, unknown>;
        LowGrayHomogeneity: t.Type<number, number, unknown>;
        CouplingOptimize2: t.Type<number, number, unknown>;
        BlankingTime1: t.Type<number, number, unknown>;
        FirstLineCompensation: t.Type<number, number, unknown>;
        LowGrayOptimize2: t.Type<number, number, unknown>;
        OpenTest: t.Type<boolean, boolean, unknown>;
        EliminateOpenCrossGrade: t.Type<number, number, unknown>;
        CouplingEnhancePattern: t.Type<boolean, boolean, unknown>;
        LowGrayOptimize1: t.Type<number, number, unknown>;
        LowGrayAcrossStripeOptimize: t.Type<number, number, unknown>;
        CouplingGrade: t.Type<number, number, unknown>;
        Gain: t.Type<number, number, unknown>;
        BlankingGrade1: t.Type<number, number, unknown>;
        FirstLineDarkCompensationGrade: t.Type<number, number, unknown>;
        BlankingOpen2: t.Type<boolean, boolean, unknown>;
        BlankingGrade2: t.Type<number, number, unknown>;
        BlankingOpen3: t.Type<boolean, boolean, unknown>;
        BlankingGrade3: t.Type<number, number, unknown>;
        CouplingOptimize1: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipSM16389ExtendProperty">;
    }>]>;
    VRedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
        REG_LENGTH: t.Type<number, number, unknown>;
        RegisterArray: t.ArrayC<t.Type<number, number, unknown>>;
    }>, t.PartialC<{
        EnergyPattern: t.Type<number, number, unknown>;
        LowGrayHomogeneity: t.Type<number, number, unknown>;
        CouplingOptimize2: t.Type<number, number, unknown>;
        BlankingTime1: t.Type<number, number, unknown>;
        FirstLineCompensation: t.Type<number, number, unknown>;
        LowGrayOptimize2: t.Type<number, number, unknown>;
        OpenTest: t.Type<boolean, boolean, unknown>;
        EliminateOpenCrossGrade: t.Type<number, number, unknown>;
        CouplingEnhancePattern: t.Type<boolean, boolean, unknown>;
        LowGrayOptimize1: t.Type<number, number, unknown>;
        LowGrayAcrossStripeOptimize: t.Type<number, number, unknown>;
        CouplingGrade: t.Type<number, number, unknown>;
        Gain: t.Type<number, number, unknown>;
        BlankingGrade1: t.Type<number, number, unknown>;
        FirstLineDarkCompensationGrade: t.Type<number, number, unknown>;
        BlankingOpen2: t.Type<boolean, boolean, unknown>;
        BlankingGrade2: t.Type<number, number, unknown>;
        BlankingOpen3: t.Type<boolean, boolean, unknown>;
        BlankingGrade3: t.Type<number, number, unknown>;
        CouplingOptimize1: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipSM16389ExtendProperty">;
    }>]>;
    IsUseNewModule: t.Type<boolean, boolean, unknown>;
    ChipLibVersion: t.Type<number, number, unknown>;
    IsAdvancedMode: t.Type<boolean, boolean, unknown>;
    TestGain: t.Type<number, number, unknown>;
    IsErrOpen: t.Type<boolean, boolean, unknown>;
    SpecialDataLen: t.Type<number, number, unknown>;
    SpecialRegisterAddr: t.Type<number, number, unknown>;
    LittlePeriodCount: t.Type<number, number, unknown>;
    RefreshMagnificationP1: t.Type<number, number, unknown>;
    RefreshMagnificationP2: t.Type<number, number, unknown>;
    RefreshMagnificationP3: t.Type<number, number, unknown>;
    LineScanGrayScale: t.Type<number, number, unknown>;
}>]>, t.PartialC<{
    '@_xsi:type': t.LiteralC<"ChipSM16389RGBVExtendProperty">;
}>]>;
export interface ChipSM16389RGBVExtendProperty extends t.TypeOf<typeof ChipSM16389RGBVExtendProperty> {
    RedProperty?: ChipSM16389ExtendProperty;
    GreenProperty?: ChipSM16389ExtendProperty;
    BlueProperty?: ChipSM16389ExtendProperty;
    VRedProperty?: ChipSM16389ExtendProperty;
}
