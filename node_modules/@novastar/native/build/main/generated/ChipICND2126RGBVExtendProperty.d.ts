import * as t from 'io-ts';
import { ChipICND2126ExtendProperty } from './ChipICND2126ExtendProperty';
import { PointDetectParameter } from './PointDetectParameter';
export declare const ChipICND2126RGBVExtendPropertyBase: t.IntersectionC<[t.PartialC<{}>, t.PartialC<{
    RedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
        ShortDetection: t.Type<number, number, unknown>;
        ErrorSurvey_OnTime: t.Type<boolean, boolean, unknown>;
        SavingPowerMode: t.Type<number, number, unknown>;
        CurrentGain: t.Type<number, number, unknown>;
        ShadowEliminationEn: t.Type<boolean, boolean, unknown>;
        InflectionPiont: t.Type<number, number, unknown>;
        ShadowEliminationElectric: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipICND2126ExtendProperty">;
    }>]>;
    GreenProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
        ShortDetection: t.Type<number, number, unknown>;
        ErrorSurvey_OnTime: t.Type<boolean, boolean, unknown>;
        SavingPowerMode: t.Type<number, number, unknown>;
        CurrentGain: t.Type<number, number, unknown>;
        ShadowEliminationEn: t.Type<boolean, boolean, unknown>;
        InflectionPiont: t.Type<number, number, unknown>;
        ShadowEliminationElectric: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipICND2126ExtendProperty">;
    }>]>;
    BlueProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
        ShortDetection: t.Type<number, number, unknown>;
        ErrorSurvey_OnTime: t.Type<boolean, boolean, unknown>;
        SavingPowerMode: t.Type<number, number, unknown>;
        CurrentGain: t.Type<number, number, unknown>;
        ShadowEliminationEn: t.Type<boolean, boolean, unknown>;
        InflectionPiont: t.Type<number, number, unknown>;
        ShadowEliminationElectric: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipICND2126ExtendProperty">;
    }>]>;
    VRedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
        ShortDetection: t.Type<number, number, unknown>;
        ErrorSurvey_OnTime: t.Type<boolean, boolean, unknown>;
        SavingPowerMode: t.Type<number, number, unknown>;
        CurrentGain: t.Type<number, number, unknown>;
        ShadowEliminationEn: t.Type<boolean, boolean, unknown>;
        InflectionPiont: t.Type<number, number, unknown>;
        ShadowEliminationElectric: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipICND2126ExtendProperty">;
    }>]>;
    IsUseNewModule: t.Type<boolean, boolean, unknown>;
    ChipLibVersion: t.Type<number, number, unknown>;
    IsAdvancedMode: t.Type<boolean, boolean, unknown>;
    PointDetectType: t.Type<number, number, unknown>;
    SetSpecialBit: t.Type<number, number, unknown>;
    FirstDataLen: t.Type<number, number, unknown>;
    FirstStartIndex: t.Type<number, number, unknown>;
    FirstRegisterAddr: t.Type<number, number, unknown>;
    SecondDataLen: t.Type<number, number, unknown>;
    SecondStartIndex: t.Type<number, number, unknown>;
    SecondRegisterAddr: t.Type<number, number, unknown>;
    PointDetectParameter: t.PartialC<{
        DetectType: t.Type<import("./DetectPointType").DetectPointTypeEnum, "None" | "EarlyDeath" | "OpenCircuit" | "ShortCircuit" | "BothDivision" | "BothNoDivision" | "FourTypesCircuit" | "FiveTypesAllIn", unknown>;
        IsUseThreshold: t.Type<boolean, boolean, unknown>;
        Threshold: t.Type<import("./ThresholdType").ThresholdTypeEnum, "None" | "Grade1" | "Grade2" | "Grade3" | "Grade4" | "Grade5" | "Grade6" | "Grade7" | "Grade8", unknown>;
        ThresholdGradeCount: t.Type<number, number, unknown>;
        IsNeedConfigRegister: t.Type<boolean, boolean, unknown>;
        ConfigGroupType: t.Type<import("./RegisterGroupType").RegisterGroupTypeEnum, "FirstGroup" | "SecondGroup" | "ThirdGroup" | "FourthGroup" | "OldChipDefaultGroup" | "SpecialGroup", unknown>;
        TheTallyMode: t.Type<number, number, unknown>;
        DetectTypeValue: t.Type<number, number, unknown>;
    }>;
}>]>;
/**
 * @category Codecs
 * @desc Codec for {@link ChipICND2126RGBVExtendProperty}
 * @see Automatically generated from ../decompiled/Nova.LCT.GigabitSystem.ChipICN2126.decompiled.cs:1400
 */
export declare const ChipICND2126RGBVExtendProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.PartialC<{
    RedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
        ShortDetection: t.Type<number, number, unknown>;
        ErrorSurvey_OnTime: t.Type<boolean, boolean, unknown>;
        SavingPowerMode: t.Type<number, number, unknown>;
        CurrentGain: t.Type<number, number, unknown>;
        ShadowEliminationEn: t.Type<boolean, boolean, unknown>;
        InflectionPiont: t.Type<number, number, unknown>;
        ShadowEliminationElectric: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipICND2126ExtendProperty">;
    }>]>;
    GreenProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
        ShortDetection: t.Type<number, number, unknown>;
        ErrorSurvey_OnTime: t.Type<boolean, boolean, unknown>;
        SavingPowerMode: t.Type<number, number, unknown>;
        CurrentGain: t.Type<number, number, unknown>;
        ShadowEliminationEn: t.Type<boolean, boolean, unknown>;
        InflectionPiont: t.Type<number, number, unknown>;
        ShadowEliminationElectric: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipICND2126ExtendProperty">;
    }>]>;
    BlueProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
        ShortDetection: t.Type<number, number, unknown>;
        ErrorSurvey_OnTime: t.Type<boolean, boolean, unknown>;
        SavingPowerMode: t.Type<number, number, unknown>;
        CurrentGain: t.Type<number, number, unknown>;
        ShadowEliminationEn: t.Type<boolean, boolean, unknown>;
        InflectionPiont: t.Type<number, number, unknown>;
        ShadowEliminationElectric: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipICND2126ExtendProperty">;
    }>]>;
    VRedProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.PartialC<{
        FirstRegValue: t.Type<number, number, unknown>;
        SecondRegValue: t.Type<number, number, unknown>;
        ShortDetection: t.Type<number, number, unknown>;
        ErrorSurvey_OnTime: t.Type<boolean, boolean, unknown>;
        SavingPowerMode: t.Type<number, number, unknown>;
        CurrentGain: t.Type<number, number, unknown>;
        ShadowEliminationEn: t.Type<boolean, boolean, unknown>;
        InflectionPiont: t.Type<number, number, unknown>;
        ShadowEliminationElectric: t.Type<number, number, unknown>;
    }>]>, t.PartialC<{
        '@_xsi:type': t.LiteralC<"ChipICND2126ExtendProperty">;
    }>]>;
    IsUseNewModule: t.Type<boolean, boolean, unknown>;
    ChipLibVersion: t.Type<number, number, unknown>;
    IsAdvancedMode: t.Type<boolean, boolean, unknown>;
    PointDetectType: t.Type<number, number, unknown>;
    SetSpecialBit: t.Type<number, number, unknown>;
    FirstDataLen: t.Type<number, number, unknown>;
    FirstStartIndex: t.Type<number, number, unknown>;
    FirstRegisterAddr: t.Type<number, number, unknown>;
    SecondDataLen: t.Type<number, number, unknown>;
    SecondStartIndex: t.Type<number, number, unknown>;
    SecondRegisterAddr: t.Type<number, number, unknown>;
    PointDetectParameter: t.PartialC<{
        DetectType: t.Type<import("./DetectPointType").DetectPointTypeEnum, "None" | "EarlyDeath" | "OpenCircuit" | "ShortCircuit" | "BothDivision" | "BothNoDivision" | "FourTypesCircuit" | "FiveTypesAllIn", unknown>;
        IsUseThreshold: t.Type<boolean, boolean, unknown>;
        Threshold: t.Type<import("./ThresholdType").ThresholdTypeEnum, "None" | "Grade1" | "Grade2" | "Grade3" | "Grade4" | "Grade5" | "Grade6" | "Grade7" | "Grade8", unknown>;
        ThresholdGradeCount: t.Type<number, number, unknown>;
        IsNeedConfigRegister: t.Type<boolean, boolean, unknown>;
        ConfigGroupType: t.Type<import("./RegisterGroupType").RegisterGroupTypeEnum, "FirstGroup" | "SecondGroup" | "ThirdGroup" | "FourthGroup" | "OldChipDefaultGroup" | "SpecialGroup", unknown>;
        TheTallyMode: t.Type<number, number, unknown>;
        DetectTypeValue: t.Type<number, number, unknown>;
    }>;
}>]>, t.PartialC<{
    '@_xsi:type': t.LiteralC<"ChipICND2126RGBVExtendProperty">;
}>]>;
export interface ChipICND2126RGBVExtendProperty extends t.TypeOf<typeof ChipICND2126RGBVExtendProperty> {
    RedProperty?: ChipICND2126ExtendProperty;
    GreenProperty?: ChipICND2126ExtendProperty;
    BlueProperty?: ChipICND2126ExtendProperty;
    VRedProperty?: ChipICND2126ExtendProperty;
    PointDetectParameter?: PointDetectParameter;
}
