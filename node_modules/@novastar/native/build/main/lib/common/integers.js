"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Base64 = exports.BufferFromBase64 = exports.withDefault = exports.UInt64 = exports.Int32 = exports.UInt32 = exports.Int16 = exports.UInt16 = exports.Int8 = exports.UInt8 = exports.Bool = exports.Numeric = void 0;
// import { Buffer } from 'buffer';
const Either_1 = require("fp-ts/Either");
const t = __importStar(require("io-ts"));
const io_ts_types_1 = require("io-ts-types");
const PathReporter_1 = require("io-ts/PathReporter");
const stringConverter = (converter) => (codec) => new t.Type(codec.name, codec.is, (u, c) => typeof u === 'string'
    ? Either_1.Chain.chain(converter.validate(u, c), n => codec.validate(n, c))
    : codec.validate(u, c), codec.encode);
const numberFromStringConverter = stringConverter(io_ts_types_1.NumberFromString);
const booleanFromStringConverter = stringConverter(io_ts_types_1.BooleanFromString);
exports.Numeric = numberFromStringConverter(t.number);
exports.Bool = booleanFromStringConverter(t.boolean);
exports.UInt8 = numberFromStringConverter((0, io_ts_types_1.fromRefinement)('UInt8', (n) => t.number.is(n) && Number.isInteger(n) && n >= 0 && n < 256));
exports.Int8 = numberFromStringConverter((0, io_ts_types_1.fromRefinement)('Int8', (n) => t.number.is(n) && Number.isInteger(n) && n >= -128 && n < 128));
exports.UInt16 = numberFromStringConverter((0, io_ts_types_1.fromRefinement)('UInt16', (n) => t.number.is(n) && Number.isInteger(n) && n >= 0 && n < 0x10000));
exports.Int16 = numberFromStringConverter((0, io_ts_types_1.fromRefinement)('Int16', (n) => t.number.is(n) && Number.isInteger(n) && n >= -32768 && n < 32768));
exports.UInt32 = numberFromStringConverter((0, io_ts_types_1.fromRefinement)('UInt32', (n) => t.number.is(n) && Number.isInteger(n) && n >= 0 && n <= 4294967295));
exports.Int32 = numberFromStringConverter((0, io_ts_types_1.fromRefinement)('Int32', (n) => t.number.is(n) && Number.isInteger(n) && n >= -2147483648 && n < 2147483648));
exports.UInt64 = stringConverter(io_ts_types_1.BigIntFromString)(t.bigint);
/*
export interface UInt8Brand {
  readonly UInt8: symbol;
}

export const UInt8 = t.brand(
  t.number,
  (n): n is t.Branded<number, UInt8Brand> => Number.isInteger(n) && n >= 0 && n < 256,
  'UInt8'
);

export type UInt8 = number & UInt8Brand;

export interface Int8Brand {
  readonly Int8: symbol;
}

export const Int8 = t.brand(
  t.number,
  (n): n is t.Branded<number, Int8Brand> => Number.isInteger(n) && n >= -128 && n < 128,
  'Int8'
);

export type Int8 = number & Int8Brand;

export interface UInt16Brand {
  readonly UInt16: symbol;
}

export const UInt16 = t.brand(
  t.number,
  (n): n is t.Branded<number, UInt16Brand> => Number.isInteger(n) && n >= 0 && n < 0x10000,
  'UInt16'
);

export type UInt16 = t.TypeOf<typeof UInt16>;

export interface Int16Brand {
  readonly Int16: symbol;
}

export const Int16 = t.brand(
  t.number,
  (n): n is t.Branded<number, Int16Brand> => Number.isInteger(n) && n >= -32768 && n < 32768,
  'Int16'
);

export type Int16 = number & Int16Brand;

export interface UInt32Brand {
  readonly UInt32: symbol;
}

export const UInt32 = t.brand(
  t.number,
  (n): n is t.Branded<number, UInt32Brand> => Number.isInteger(n) && n >= 0 && n <= 4294967295,
  'UInt32'
);

export type UInt32 = number & UInt32Brand;

export interface Int32Brand {
  readonly Int32: symbol;
}

export const Int32 = t.brand(
  t.number,
  (n): n is t.Branded<number, Int32Brand> =>
    Number.isInteger(n) && n >= -2147483648 && n < 2147483648,
  'Int32'
);

export type Int32 = number & Int32Brand;

*/
function withDefault(codec, defaultValue) {
    let value = defaultValue;
    if (!codec.is(value)) {
        const validation = codec.decode(value);
        if ((0, Either_1.isLeft)(validation))
            throw new TypeError(PathReporter_1.PathReporter.report(validation).join('\n'));
        value = validation.right;
    }
    return (0, io_ts_types_1.fromNullable)(codec, value);
}
exports.withDefault = withDefault;
class BufferFromBase64 extends t.Type {
    constructor(name, length, strict = false) {
        super(name, (u) => u instanceof Uint8Array && (!length || u.length === length), (i, c) => {
            if (typeof i === 'string' &&
                /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(i)) {
                const buffer = Uint8Array.from(atob(i), c => c.charCodeAt(0)); // Buffer.from(i, 'base64');
                if (!length ||
                    (buffer.length === length && strict) ||
                    (buffer.length >= length && !strict)) {
                    return t.success(buffer);
                }
                t.failure(buffer, c, `Invalid length: expected ${length} but got ${buffer.length}`);
            }
            return t.failure(i, c, 'Invalid base64');
        }, b => btoa(String.fromCharCode.apply(null, [...b])));
    }
}
exports.BufferFromBase64 = BufferFromBase64;
exports.Base64 = new BufferFromBase64('Base64');
//# sourceMappingURL=integers.js.map