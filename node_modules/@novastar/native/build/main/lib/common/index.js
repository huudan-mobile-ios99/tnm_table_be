"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.omit = exports.makeStruct = exports.XMLArray = exports.PointFromString = void 0;
/* eslint-disable @typescript-eslint/ban-types,no-underscore-dangle */
const Either_1 = require("fp-ts/Either");
const function_1 = require("fp-ts/function");
const t = __importStar(require("io-ts"));
const PathReporter_1 = require("io-ts/PathReporter");
__exportStar(require("./integers"), exports);
__exportStar(require("./types"), exports);
const Point = t.type({
    x: t.number,
    y: t.number,
});
exports.PointFromString = new t.Type('Point', (u) => Point.is(u), (u, c) => {
    if (typeof u === 'string') {
        const values = u.split(',');
        if (values.length === 2) {
            const [x, y] = values.map(Number);
            if (Number.isInteger(x) && Number.isInteger(y))
                return t.success({
                    x,
                    y,
                });
        }
    }
    else if (Point.is(u))
        return t.success(u);
    return t.failure(u, c, `Invalid Point: ${typeof u}, ${JSON.stringify(u)}`);
}, a => `${BigInt(a.x)}, ${BigInt(a.y)}`);
const toArray = (value) => (Array.isArray(value) ? value : [value]);
const capitalizeFirstLetter = (str) => `${str.charAt(0).toUpperCase()}${str.slice(1)}`;
const XMLArray = (item, itemTypeName) => new t.ArrayType(`${capitalizeFirstLetter(itemTypeName)}Array`, (u) => t.UnknownArray.is(u) && u.every(item.is), (u, c) => !u
    ? t.success([])
    : (0, function_1.pipe)(t
        .array(item)
        .validate(toArray(Object.prototype.hasOwnProperty.call(u, itemTypeName)
        ? u[itemTypeName]
        : u), c), (0, Either_1.chain)(a => t.success(a))), item.encode === t.identity ? t.identity : a => a.map(item.encode), item);
exports.XMLArray = XMLArray;
// type DeepPartial<T> = {
//   [P in keyof T]?: DeepPartial<T[P]>;
// };
function makeStruct(codec, initializer) {
    const v = codec.decode(initializer);
    if ((0, Either_1.isLeft)(v))
        throw new TypeError(`Invalid value: ${PathReporter_1.PathReporter.report(v)}`);
    return v.right;
}
exports.makeStruct = makeStruct;
function getProps(codec) {
    switch (codec._tag) {
        case 'RefinementType':
        case 'ReadonlyType':
            return getProps(codec.type);
        case 'InterfaceType':
        case 'StrictType':
        case 'PartialType':
            return codec.props;
        case 'IntersectionType':
            return codec.types.reduce((props, type) => Object.assign(props, getProps(type)), {});
        default:
            throw new TypeError('Invalid codec');
    }
}
const omit = (codec, k) => {
    const { [k]: prop, ...props } = getProps(codec);
    return t.type(props);
};
exports.omit = omit;
//# sourceMappingURL=index.js.map