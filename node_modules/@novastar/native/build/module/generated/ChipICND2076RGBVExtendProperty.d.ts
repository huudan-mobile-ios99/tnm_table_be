import * as t from 'io-ts';
export declare const ChipICND2076RGBVExtendPropertyBase: t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
    REG_LENGTH: t.Type<number, number, unknown>;
    RegisterList: t.ArrayC<t.Type<bigint, bigint, unknown>>;
    RRemovePointCurrentAmplitude: t.Type<number, number, unknown>;
    GRemovePointCurrentAmplitude: t.Type<number, number, unknown>;
    BRemovePointCurrentAmplitude: t.Type<number, number, unknown>;
}>, t.PartialC<{
    IsUseNewModule: t.Type<boolean, boolean, unknown>;
    SpecialDataLen: t.Type<number, number, unknown>;
    SpecialRegisterAddr: t.Type<number, number, unknown>;
    RShadowEliminationLevel: t.Type<number, number, unknown>;
    GShadowEliminationLevel: t.Type<number, number, unknown>;
    BShadowEliminationLevel: t.Type<number, number, unknown>;
    RShadowEliminationTime: t.Type<number, number, unknown>;
    GShadowEliminationTime: t.Type<number, number, unknown>;
    BShadowEliminationTime: t.Type<number, number, unknown>;
    LowAshuniformity: t.Type<number, number, unknown>;
    RLowGrayOffset: t.Type<number, number, unknown>;
    GLowGrayOffset: t.Type<number, number, unknown>;
    BLowGrayOffset: t.Type<number, number, unknown>;
    RFirstLineDarkCompsentionTime: t.Type<number, number, unknown>;
    GFirstLineDarkCompsentionTime: t.Type<number, number, unknown>;
    BFirstLineDarkCompsentionTime: t.Type<number, number, unknown>;
    RLowGrayFirstLineDarkCompsention: t.Type<number, number, unknown>;
    GLowGrayFirstLineDarkCompsention: t.Type<number, number, unknown>;
    BLowGrayFirstLineDarkCompsention: t.Type<number, number, unknown>;
    RLowGrayFirstLineDarkCompsentionFineTuning: t.Type<number, number, unknown>;
    GLowGrayFirstLineDarkCompsentionFineTuning: t.Type<number, number, unknown>;
    BLowGrayFirstLineDarkCompsentionFineTuning: t.Type<number, number, unknown>;
    RLowGrayFirstLineDarkCompsentionEn: t.Type<boolean, boolean, unknown>;
    GLowGrayFirstLineDarkCompsentionEn: t.Type<boolean, boolean, unknown>;
    BLowGrayFirstLineDarkCompsentionEn: t.Type<boolean, boolean, unknown>;
    CouplingAdjustEnhacneModeEn: t.Type<boolean, boolean, unknown>;
    CouplingOptimizationOne: t.Type<number, number, unknown>;
    RCouplingOptimizationTwoEn: t.Type<boolean, boolean, unknown>;
    GCouplingOptimizationTwoEn: t.Type<boolean, boolean, unknown>;
    BCouplingOptimizationTwoEn: t.Type<boolean, boolean, unknown>;
    RCouplingOptimizationTwo: t.Type<number, number, unknown>;
    GCouplingOptimizationTwo: t.Type<number, number, unknown>;
    BCouplingOptimizationTwo: t.Type<number, number, unknown>;
    RSlowlyOpen: t.Type<number, number, unknown>;
    GSlowlyOpen: t.Type<number, number, unknown>;
    BSlowlyOpen: t.Type<number, number, unknown>;
    RKneePointVoltage: t.Type<number, number, unknown>;
    GKneePointVoltage: t.Type<number, number, unknown>;
    BKneePointVoltage: t.Type<number, number, unknown>;
    RCurrentGain: t.Type<number, number, unknown>;
    GCurrentGain: t.Type<number, number, unknown>;
    BCurrentGain: t.Type<number, number, unknown>;
    RCurrentAmplitude: t.Type<number, number, unknown>;
    GCurrentAmplitude: t.Type<number, number, unknown>;
    BCurrentAmplitude: t.Type<number, number, unknown>;
    IsAdvancedMode: t.Type<boolean, boolean, unknown>;
    GclkNumPerScan: t.Type<number, number, unknown>;
    ScanCount: t.Type<number, number, unknown>;
    RefNumPerVs: t.Type<number, number, unknown>;
    GclkFreqP: t.Type<number, number, unknown>;
    GclkFreqM: t.Type<number, number, unknown>;
    GclkFreqN: t.Type<number, number, unknown>;
    FailureEliminationEn: t.Type<boolean, boolean, unknown>;
}>]>;
/**
 * @category Codecs
 * @desc Codec for {@link ChipICND2076RGBVExtendProperty}
 * @see Automatically generated from ../decompiled/Nova.LCT.GigabitSystem.ChipICND2076.decompiled.cs:86
 */
export declare const ChipICND2076RGBVExtendProperty: t.IntersectionC<[t.IntersectionC<[t.PartialC<{}>, t.TypeC<{
    REG_LENGTH: t.Type<number, number, unknown>;
    RegisterList: t.ArrayC<t.Type<bigint, bigint, unknown>>;
    RRemovePointCurrentAmplitude: t.Type<number, number, unknown>;
    GRemovePointCurrentAmplitude: t.Type<number, number, unknown>;
    BRemovePointCurrentAmplitude: t.Type<number, number, unknown>;
}>, t.PartialC<{
    IsUseNewModule: t.Type<boolean, boolean, unknown>;
    SpecialDataLen: t.Type<number, number, unknown>;
    SpecialRegisterAddr: t.Type<number, number, unknown>;
    RShadowEliminationLevel: t.Type<number, number, unknown>;
    GShadowEliminationLevel: t.Type<number, number, unknown>;
    BShadowEliminationLevel: t.Type<number, number, unknown>;
    RShadowEliminationTime: t.Type<number, number, unknown>;
    GShadowEliminationTime: t.Type<number, number, unknown>;
    BShadowEliminationTime: t.Type<number, number, unknown>;
    LowAshuniformity: t.Type<number, number, unknown>;
    RLowGrayOffset: t.Type<number, number, unknown>;
    GLowGrayOffset: t.Type<number, number, unknown>;
    BLowGrayOffset: t.Type<number, number, unknown>;
    RFirstLineDarkCompsentionTime: t.Type<number, number, unknown>;
    GFirstLineDarkCompsentionTime: t.Type<number, number, unknown>;
    BFirstLineDarkCompsentionTime: t.Type<number, number, unknown>;
    RLowGrayFirstLineDarkCompsention: t.Type<number, number, unknown>;
    GLowGrayFirstLineDarkCompsention: t.Type<number, number, unknown>;
    BLowGrayFirstLineDarkCompsention: t.Type<number, number, unknown>;
    RLowGrayFirstLineDarkCompsentionFineTuning: t.Type<number, number, unknown>;
    GLowGrayFirstLineDarkCompsentionFineTuning: t.Type<number, number, unknown>;
    BLowGrayFirstLineDarkCompsentionFineTuning: t.Type<number, number, unknown>;
    RLowGrayFirstLineDarkCompsentionEn: t.Type<boolean, boolean, unknown>;
    GLowGrayFirstLineDarkCompsentionEn: t.Type<boolean, boolean, unknown>;
    BLowGrayFirstLineDarkCompsentionEn: t.Type<boolean, boolean, unknown>;
    CouplingAdjustEnhacneModeEn: t.Type<boolean, boolean, unknown>;
    CouplingOptimizationOne: t.Type<number, number, unknown>;
    RCouplingOptimizationTwoEn: t.Type<boolean, boolean, unknown>;
    GCouplingOptimizationTwoEn: t.Type<boolean, boolean, unknown>;
    BCouplingOptimizationTwoEn: t.Type<boolean, boolean, unknown>;
    RCouplingOptimizationTwo: t.Type<number, number, unknown>;
    GCouplingOptimizationTwo: t.Type<number, number, unknown>;
    BCouplingOptimizationTwo: t.Type<number, number, unknown>;
    RSlowlyOpen: t.Type<number, number, unknown>;
    GSlowlyOpen: t.Type<number, number, unknown>;
    BSlowlyOpen: t.Type<number, number, unknown>;
    RKneePointVoltage: t.Type<number, number, unknown>;
    GKneePointVoltage: t.Type<number, number, unknown>;
    BKneePointVoltage: t.Type<number, number, unknown>;
    RCurrentGain: t.Type<number, number, unknown>;
    GCurrentGain: t.Type<number, number, unknown>;
    BCurrentGain: t.Type<number, number, unknown>;
    RCurrentAmplitude: t.Type<number, number, unknown>;
    GCurrentAmplitude: t.Type<number, number, unknown>;
    BCurrentAmplitude: t.Type<number, number, unknown>;
    IsAdvancedMode: t.Type<boolean, boolean, unknown>;
    GclkNumPerScan: t.Type<number, number, unknown>;
    ScanCount: t.Type<number, number, unknown>;
    RefNumPerVs: t.Type<number, number, unknown>;
    GclkFreqP: t.Type<number, number, unknown>;
    GclkFreqM: t.Type<number, number, unknown>;
    GclkFreqN: t.Type<number, number, unknown>;
    FailureEliminationEn: t.Type<boolean, boolean, unknown>;
}>]>, t.PartialC<{
    '@_xsi:type': t.LiteralC<"ChipICND2076RGBVExtendProperty">;
}>]>;
export interface ChipICND2076RGBVExtendProperty extends t.TypeOf<typeof ChipICND2076RGBVExtendProperty> {
}
