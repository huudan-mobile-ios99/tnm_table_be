/* eslint-disable @typescript-eslint/ban-types,no-underscore-dangle */
import { chain, isLeft } from 'fp-ts/Either';
import { pipe } from 'fp-ts/function';
import * as t from 'io-ts';
import { PathReporter } from 'io-ts/PathReporter';
export * from './integers';
export * from './types';
const Point = t.type({
    x: t.number,
    y: t.number,
});
export const PointFromString = new t.Type('Point', (u) => Point.is(u), (u, c) => {
    if (typeof u === 'string') {
        const values = u.split(',');
        if (values.length === 2) {
            const [x, y] = values.map(Number);
            if (Number.isInteger(x) && Number.isInteger(y))
                return t.success({
                    x,
                    y,
                });
        }
    }
    else if (Point.is(u))
        return t.success(u);
    return t.failure(u, c, `Invalid Point: ${typeof u}, ${JSON.stringify(u)}`);
}, a => `${BigInt(a.x)}, ${BigInt(a.y)}`);
const toArray = (value) => (Array.isArray(value) ? value : [value]);
const capitalizeFirstLetter = (str) => `${str.charAt(0).toUpperCase()}${str.slice(1)}`;
export const XMLArray = (item, itemTypeName) => new t.ArrayType(`${capitalizeFirstLetter(itemTypeName)}Array`, (u) => t.UnknownArray.is(u) && u.every(item.is), (u, c) => !u
    ? t.success([])
    : pipe(t
        .array(item)
        .validate(toArray(Object.prototype.hasOwnProperty.call(u, itemTypeName)
        ? u[itemTypeName]
        : u), c), chain(a => t.success(a))), item.encode === t.identity ? t.identity : a => a.map(item.encode), item);
// type DeepPartial<T> = {
//   [P in keyof T]?: DeepPartial<T[P]>;
// };
export function makeStruct(codec, initializer) {
    const v = codec.decode(initializer);
    if (isLeft(v))
        throw new TypeError(`Invalid value: ${PathReporter.report(v)}`);
    return v.right;
}
function getProps(codec) {
    switch (codec._tag) {
        case 'RefinementType':
        case 'ReadonlyType':
            return getProps(codec.type);
        case 'InterfaceType':
        case 'StrictType':
        case 'PartialType':
            return codec.props;
        case 'IntersectionType':
            return codec.types.reduce((props, type) => Object.assign(props, getProps(type)), {});
        default:
            throw new TypeError('Invalid codec');
    }
}
export const omit = (codec, k) => {
    const { [k]: prop, ...props } = getProps(codec);
    return t.type(props);
};
//# sourceMappingURL=index.js.map