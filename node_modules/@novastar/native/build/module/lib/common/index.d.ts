import * as t from 'io-ts';
export * from './integers';
export * from './types';
declare const Point: t.TypeC<{
    x: t.NumberC;
    y: t.NumberC;
}>;
export type Point = t.TypeOf<typeof Point>;
export declare const PointFromString: t.Type<{
    x: number;
    y: number;
}, `${bigint}, ${bigint}`, unknown>;
export declare const XMLArray: <C extends t.Mixed>(item: C, itemTypeName: string) => t.ArrayC<C>;
type Mix<A, B> = {
    [P in keyof (A | B)]: A[P] | B[P];
};
type FilterFlags<Base, Condition> = {
    [Key in keyof Base]: Base[Key] extends Condition ? Key : never;
};
type ExcludeFlags<Base, Condition> = {
    [Key in keyof Base]: Base[Key] extends Condition ? never : Key;
};
type AllowedNames<Base, Condition> = FilterFlags<Base, Condition>[keyof Base];
type ExcludeNames<Base, Condition> = ExcludeFlags<Base, Condition>[keyof Base];
export type SubType<Base, Condition> = Pick<Base, AllowedNames<Base, Condition>>;
type RequiredKeys<T> = {
    [K in keyof T]-?: T[K] extends Exclude<T[K], undefined> ? K : never;
}[keyof T];
export type Id<T> = {} & {
    [P in keyof T]: T[P];
};
export declare function makeStruct<C extends t.Mixed, I extends Mix<t.TypeOf<C>, t.OutputOf<C>>>(codec: C, initializer: Partial<I>): Id<Required<Pick<t.TypeOf<C>, RequiredKeys<I>>> & Pick<t.TypeOf<C>, ExcludeNames<I, undefined>>>;
export declare const omit: <C extends t.HasProps, O extends keyof t.TypeOf<C>>(codec: C, k: O) => t.TypeC<Omit<t.Props, O>>;
