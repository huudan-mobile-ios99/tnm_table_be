"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _NetBinding_sessions;
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetBinding = exports.findNetDevices = exports.TCP_PORT = exports.RES = exports.REQ = exports.MULTICAST_ADDRESS = exports.UDP_PORT = void 0;
const dgram = __importStar(require("dgram"));
const net_1 = require("net");
const os_1 = __importDefault(require("os"));
const codec_1 = require("@novastar/codec");
const debug_1 = __importDefault(require("debug"));
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const debug = (0, debug_1.default)('novastar:net');
exports.UDP_PORT = 3800;
exports.MULTICAST_ADDRESS = '224.224.125.119';
const UDP_TIMEOUT = 1000;
exports.REQ = 'rqProMI:';
exports.RES = 'rpProMI:';
exports.TCP_PORT = 5200;
const TCP_TIMEOUT = 1000;
const KEEP_ALIVE_DELAY = 30000;
const interfaceSearch = (address, dest = '255.255.255.255') => new Promise(resolve => {
    const socket = dgram.createSocket('udp4');
    let completed = false;
    let timer;
    const list = [];
    const complete = () => {
        timer && clearTimeout(timer);
        socket.close();
        if (!completed) {
            completed = true;
            resolve(list);
            // debug(`stop: ${address}`);
        }
    };
    socket.on('error', complete);
    socket.on('message', (msg, rinfo) => {
        if (msg.toString().startsWith(exports.RES) && !completed && !list.includes(rinfo.address)) {
            list.push(rinfo.address);
            // debug(`found: ${rinfo.address}`);
        }
    });
    socket.bind(exports.UDP_PORT, address, () => {
        socket.setBroadcast(true);
        socket.addMembership(exports.MULTICAST_ADDRESS, address);
        socket.setMulticastTTL(128);
        timer = setTimeout(complete, UDP_TIMEOUT);
        socket.send(exports.REQ, exports.UDP_PORT, dest, err => err && complete());
        // debug(`start: ${address}`);
    });
});
/**
 * Finding network devices
 * @returns {Promise<string[]>} - addresses of found devices
 */
const findNetDevices = async (dest) => {
    const interfaces = Object.values(os_1.default.networkInterfaces())
        .filter(codec_1.notEmpty)
        .reduce((res, values) => [...res, ...values], [])
        .filter(nic => !nic.internal && nic.family === 'IPv4')
        .map(({ address }) => address);
    const results = await Promise.all(interfaces.map(address => interfaceSearch(address, dest)));
    return results.reduce((acc, list) => [...acc, ...list.filter(host => !acc.includes(host))], []);
};
exports.findNetDevices = findNetDevices;
const parseAddress = (address) => {
    const [host, port = exports.TCP_PORT] = address.split(':', 2);
    return [host, +port];
};
/**
 * @internal For documentation purposes only. Use singleton instance exported as default
 */
class NetBinding extends tiny_typed_emitter_1.TypedEmitter {
    constructor() {
        super(...arguments);
        _NetBinding_sessions.set(this, {});
    }
    /**
     * Get all network sessions
     */
    get sessions() {
        return __classPrivateFieldGet(this, _NetBinding_sessions, "f");
    }
    /**
     * Connect to network device and open a new session
     * @param address host(:port)?
     */
    open(address) {
        const [host, port] = parseAddress(address);
        const fullAddress = `${host}:${port}`;
        if (this.sessions[fullAddress])
            return this.sessions[fullAddress];
        const socket = (0, net_1.createConnection)(port, host);
        const connection = new codec_1.Connection(socket, false, TCP_TIMEOUT);
        socket.on('connect', () => {
            connection.open();
        });
        connection.on('open', () => {
            this.emit('open', fullAddress);
            debug(`connection ${fullAddress} opened`);
        });
        socket.setKeepAlive(true, KEEP_ALIVE_DELAY);
        const session = new codec_1.Session(connection);
        __classPrivateFieldGet(this, _NetBinding_sessions, "f")[fullAddress] = session;
        let reconnectRequired = true;
        socket.on('error', err => {
            const { code } = err;
            if (code && ['ECONNREFUSED', 'ECONNRESET'].includes(code))
                reconnectRequired = false;
        });
        socket.on('close', async (hadError) => {
            connection.close();
            if (hadError && reconnectRequired) {
                debug('try reconnect');
                reconnectRequired = false;
                this.emit('disconnect', fullAddress);
                await (0, codec_1.delay)(1000);
                socket.connect(port, host, () => {
                    reconnectRequired = true;
                });
            }
            else {
                delete __classPrivateFieldGet(this, _NetBinding_sessions, "f")[fullAddress];
                this.close(fullAddress);
                this.emit('close', fullAddress);
            }
        });
        return session;
    }
    /**
     * Close network session
     * @param address host(:port)?
     * @returns `false` if no connection is found
     */
    close(address) {
        const [host, port] = parseAddress(address);
        const fullAddress = `${host}:${port}`;
        const session = this.sessions[fullAddress];
        if (session) {
            const { connection } = session;
            const { stream: socket } = connection;
            if (!socket.destroyed)
                socket.destroy();
            debug(`connection ${fullAddress} closed`);
        }
        return session !== undefined;
    }
    /**
     * Close all network sessions
     */
    release() {
        Object.values(this.sessions).forEach(session => session.close());
    }
}
exports.NetBinding = NetBinding;
_NetBinding_sessions = new WeakMap();
/**
 * Binding to work with network devices
 */
const net = new NetBinding();
exports.default = net;
//# sourceMappingURL=net.js.map