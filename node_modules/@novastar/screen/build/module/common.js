/* eslint-disable no-bitwise */
import { compress, decompress } from '@sarakusha/lzma';
import { LEDDisplyTypeEnum } from '@novastar/native/LEDDisplyType';
import { ScanBoardConnectTypeEnum } from '@novastar/native/ScanBoardConnectType';
import groupBy from 'lodash/groupBy';
/**
 * 'Not Empty' type guard
 * @param value
 */
export function notEmpty(value) {
    return (value !== undefined && value !== null && (typeof value !== 'number' || !Number.isNaN(value)));
}
export const crc16 = (data, initial) => data.reduce((acc, value) => (acc + value) & 0xffff, initial);
export const crc8 = (data, initial = 0) => data.reduce((acc, value) => (acc + value) & 0xff, initial);
/*
props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);

SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
{
  UInt32 dicSize;
  Byte d;

  if (size < LZMA_PROPS_SIZE)
    return SZ_ERROR_UNSUPPORTED;
  else
    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);

  if (dicSize < LZMA_DIC_MIN)
    dicSize = LZMA_DIC_MIN;
  p->dicSize = dicSize;

  d = data[0];
  if (d >= (9 * 5 * 5))
    return SZ_ERROR_UNSUPPORTED;

  p->lc = (Byte)(d % 9);
  d /= 9;
  p->pb = (Byte)(d / 5);
  p->lp = (Byte)(d % 5);

  return SZ_OK;
}
 */
export const unpack = (props, length, buffer) => {
    const propsBuf = Buffer.isBuffer(props) ? props : Buffer.from(props, 'binary');
    if (propsBuf.length !== 5)
        throw new TypeError('Invalid props length');
    const lengthBuf = Buffer.alloc(8);
    if (length === -1)
        lengthBuf.fill(0xff);
    else
        lengthBuf.writeUInt32LE(length);
    const data = Buffer.concat([propsBuf, lengthBuf, buffer]);
    return new Promise((resolve, reject) => {
        decompress(data, (res, err) => {
            if (res)
                resolve(Buffer.from(res).toString());
            else
                reject(err);
        });
    });
};
export const pack = async (data) => {
    const compressed = await new Promise((resolve, reject) => {
        compress(data, 8, (res, err) => {
            if (res)
                resolve(Buffer.from(res));
            else
                reject(err);
        });
    });
    return [compressed.slice(0, 5).toString('binary'), compressed.slice(5 + 8)];
};
export const isHorizontalConnection = (connectType) => connectType === ScanBoardConnectTypeEnum.LeftTop_Horizontal ||
    connectType === ScanBoardConnectTypeEnum.LeftBottom_Horizontal ||
    connectType === ScanBoardConnectTypeEnum.RightTop_Horizontal ||
    connectType === ScanBoardConnectTypeEnum.RightBottom_Horizontal;
export const isTopConnection = (connectType) => connectType === ScanBoardConnectTypeEnum.LeftTop_Horizontal ||
    connectType === ScanBoardConnectTypeEnum.RightTop_Horizontal ||
    connectType === ScanBoardConnectTypeEnum.LeftTop_Vertical ||
    connectType === ScanBoardConnectTypeEnum.RightTop_Vertical;
export const isLeftConnection = (connectType) => connectType === ScanBoardConnectTypeEnum.LeftTop_Horizontal ||
    connectType === ScanBoardConnectTypeEnum.LeftTop_Vertical ||
    connectType === ScanBoardConnectTypeEnum.LeftBottom_Horizontal ||
    connectType === ScanBoardConnectTypeEnum.LeftBottom_Vertical;
export const minimax = (min, max, value) => Math.min(Math.max(value, min), max);
export const isSimpleScreen = (screen) => screen.Type === LEDDisplyTypeEnum.SimpleSingleType;
export const isStandardScreen = (screen) => screen.Type === LEDDisplyTypeEnum.StandardType;
export const isComplexScreen = (screen) => screen.Type === LEDDisplyTypeEnum.ComplexType;
export const hasProps = (...props) => (y) => notEmpty(y) && props.reduce((acc, name) => acc && notEmpty(y[name]), true);
const zipProps = (props) => (item) => props.map(name => item[name]).join(':');
const unzipProps = (props, key) => key
    .split(':')
    .map(Number)
    .reduce((acc, value, i) => ({
    ...acc,
    [props[i]]: value,
}), {});
export const groupByProps = (...props) => (list) => Object.entries(groupBy(list, zipProps(props))).map(([key, items]) => [unzipProps(props, key), items]);
export const itFirstNotNull = async (it) => {
    for await (const res of it) {
        if (res !== null)
            return res;
    }
    return null;
};
export const itAll = async (it) => {
    const all = [];
    for await (const res of it) {
        all.push(res);
    }
    return all;
};
export const toHex = (value) => {
    const hex = value.toString(16);
    const pos = hex.length - 4;
    return pos > 0 ? `0x${hex.slice(0, pos)}_${hex.slice(pos)}` : `${value > 9 ? '0x' : ''}${hex}`;
};
//# sourceMappingURL=common.js.map