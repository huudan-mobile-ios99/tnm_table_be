/// <reference types="node" />
/// <reference types="node" />
import { Duplex } from 'stream';
import { ErrorType, Packet, Request } from '@novastar/codec';
import Connection from '@novastar/codec/Connection';
import type { ScanBoardProperty } from '@novastar/native/ScanBoardProperty';
import type { SenderModulationInfo } from '@novastar/native/SenderModulationInfo';
import type { SenderRedundancyInfo } from '@novastar/native/SenderRedundancyInfo';
import { TestModeEnum } from '@novastar/native/TestMode';
import { DeviceInfo } from './DeviceInfo';
import { SessionAPI } from './Session';
import { AllowedNames, LEDDisplayInfo } from './common';
export declare const AllSenders = 255;
export declare const AllPorts = 255;
export declare const AllScanBoards = 65535;
type ConsolidatedResult = null | boolean;
export type BrightnessRGBV = {
    overall: number;
    red: number;
    green: number;
    blue: number;
    vRed: number;
};
type ReadFunction<T> = (SenderIndex: number, PortIndex: number, ScanIndex: number) => Promise<T>;
type WriteFunction<T> = (SenderIndex: number, PortIndex: number, ScanIndex: number, broadcast: boolean, value: T) => Promise<void>;
type ReadNames<T = number | Buffer> = AllowedNames<SessionAPI, ReadFunction<T>>;
type WriteNames<T = any> = AllowedNames<SessionAPI, WriteFunction<T>>;
type FilterHasTry<T> = {
    [Key in keyof T]: Key extends string ? (`try${Key}` extends keyof T ? Key : never) : never;
};
type ValueType<T> = T extends WriteFunction<infer V> ? V : never;
type ValueTypeFromName<N extends WriteNames> = ValueType<SessionAPI[N]>;
/**
 * Factory method for creating an asynchronous generator function to sequentially read data from
 * all receiving cards of the specified screen.
 * @template T Return type
 * @param screen Selected screen
 */
export type ScreenReadAsyncGenerator<T> = (screen?: number) => AsyncGenerator<T | null>;
export type ScreenWriter<T> = (value: T, screen?: number) => Promise<ConsolidatedResult>;
type Codec<I, O = I> = (value: I) => O;
/**
 *
 */
export default class ScreenConfigurator {
    #private;
    /**
     * Current session
     */
    readonly session: SessionAPI;
    /**
     * Find all connected devices in the current session/connection, read screen configurations.
     */
    reload: () => Promise<void>;
    /**
     * Save screen configurations to devices.
     */
    save: () => Promise<void>;
    ReadHWStatus: ScreenReadAsyncGenerator<{
        tempInfoInScanCard: {
            IsValid: number;
            Value: number;
        };
        humidityInfoInScanCard: {
            IsValid: number;
            Value: number;
        };
        voltageInfoInScanCard: {
            IsValid: number;
            Value: number;
        };
        isConnectMonitorCard: boolean;
        tempInfoInMonitorCard: {
            IsValid: number;
            Value: number;
        };
        humidityInfoInMonitorCard: {
            IsValid: number;
            Value: number;
        };
        smokeWarnInfo: {
            IsValid: number;
            Value: number;
        };
        fanSpeedInfoListMonitorCard: {
            IsValid: number;
            readonly Value: number;
        }[];
        valtageInfoListMonitorCard: {
            IsValid: number;
            readonly Value: number;
        }[];
        analogInputData: number[];
        generalStatus: number;
        moduleStatusLow: number[];
        moduleStatusHigh: number[];
    }>;
    ReadReceivingCardMCURemarks: ScreenReadAsyncGenerator<string>;
    ReadReceivingCardFPGARemarks: ScreenReadAsyncGenerator<string>;
    ReadChipType: ScreenReadAsyncGenerator<number>;
    ReadFirstChipType: (screen?: number | undefined) => Promise<number | null>;
    WriteBrightness: ScreenWriter<number>;
    ReadBrightness: ScreenReadAsyncGenerator<number>;
    ReadFirstBrightness: (screen?: number | undefined) => Promise<number | null>;
    WriteDisplayMode: ScreenWriter<TestModeEnum>;
    ReadDisplayMode: ScreenReadAsyncGenerator<number>;
    ReadFirstDisplayMode: (screen?: number | undefined) => Promise<number | null>;
    ReadGamma: ScreenReadAsyncGenerator<number>;
    ReadFirstGamma: (screen?: number | undefined) => Promise<number | null>;
    ReadRGBVBrightness: ScreenReadAsyncGenerator<BrightnessRGBV>;
    ReadFirstRGBVBrightness: (screen?: number | undefined) => Promise<BrightnessRGBV | null>;
    WriteGamma: ScreenWriter<number>;
    ReadFirstFuncCardLightSensor: (screen?: number | undefined) => Promise<number | null>;
    ReadFuncCardLightSensor: (...args: (number | undefined)[]) => Promise<number | null>;
    constructor(connection: Connection<Duplex>);
    constructor(session: SessionAPI);
    get devices(): ReadonlyArray<Readonly<DeviceInfo>>;
    get screens(): ReadonlyArray<Readonly<LEDDisplayInfo>>;
    get reduList(): ReadonlyArray<Readonly<Required<SenderRedundancyInfo>>>;
    get modulations(): ReadonlyArray<Readonly<Required<SenderModulationInfo>>>;
    reset(): void;
    /**
     * FormMain
     */
    GetScreenAllPort(screen: number, toRead?: boolean): {
        SenderIndex: number;
        PortIndex: number;
        ScanIndex: number;
        SlaveSenderIndex?: number;
        SlavePortIndex?: number;
    }[];
    WriteRGBVBrightness({ overall, red, green, blue, vRed }: BrightnessRGBV, screen?: number): Promise<null | boolean>;
    FactoryReset(screen?: number): Promise<ErrorType | null>;
    SendRemoveDeadPixels(): Promise<boolean | null>;
    ReadHasDVISignalIn(device?: number): Promise<boolean | null>;
    ReadAllFuncCardLightSensor(): AsyncGenerator<number | null>;
    protected readFuncCardLightSensorImpl(senderIndex?: number, portIndex?: number, cardIndex?: number): Promise<number | null>;
    protected createReadGenerator<N extends ReadNames, T>(name: N, decoder: (res: Packet) => T): ScreenReadAsyncGenerator<T>;
    protected createWriter<N extends FilterHasTry<SessionAPI>[WriteNames], I = ValueTypeFromName<N>>(name: N, encoder?: Codec<I, ValueTypeFromName<N>>): ScreenWriter<I>;
    protected queue<A, R>(func: (this: ScreenConfigurator, ...args: A[]) => Promise<R>): (...args: A[]) => Promise<R>;
    /**
     * ScreenInfoAccessor::LoadDviScreenInfoFromHW
     * NovaLCT::FormMain::OnEquipmentChangeEvent
     */
    protected reloadImpl(): Promise<void>;
    /**
     * Nova.LCT.GigabitSystem.CommonInfoAccessor.dll
     *
     * Nova.LCT.GigabitSystem.CommonInfoAccessor::ScreenInfoAccessor::SaveDviScreenInfoToHW
     * @protected
     */
    protected saveImpl(): Promise<void>;
    protected saveRedundancy(index: number): Promise<void>;
    protected sendParametersToScanBoardGroupImpl(scanBdProperty: Readonly<ScanBoardProperty>, isSmartMode?: boolean, isSmartNoSend?: boolean, senderIndex?: number, portIndex?: number, scanBdIndex?: number): Promise<void>;
    /**
     * Nova.LCT.GigabitSystem.LEDConfigAccessor
     *
     * Nova.LCT.GigabitSystem.HWConfigAccessor::PollingScannerParam
     *
     * ScannerPropertyAccessor::StartPollingScannerAccessor
     * @constructor
     * @protected
     */
    protected ExecuteCheck(req: Readonly<Request>): Promise<void>;
    /**
     * Nova.LCT.GigabitSystem.CommonInfoAccessor, RedundancyInfoAccessor
     */
    private readRedundancy;
    private readModulation;
    private saveModulation;
    private readBase;
    /**
     * Nova.GigabitController.FrmSysConfigMode
     */
    private SetScreenALLWidth;
    private ReadDviScreenInfo;
    private ReadSenderScreenConfigInfo;
    private ReadData;
    private WriteData;
    private ReadSoftSpaceData;
}
export {};
