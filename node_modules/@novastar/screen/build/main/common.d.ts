/// <reference types="node" />
import { ComplexLEDDisplayInfo } from '@novastar/native/ComplexLEDDisplayInfo';
import { ScanBoardConnectTypeEnum } from '@novastar/native/ScanBoardConnectType';
import { SimpleLEDDisplayInfo } from '@novastar/native/SimpleLEDDisplayInfo';
import { StandardLEDDisplayInfo } from '@novastar/native/StandardLEDDisplayInfo';
/**
 * 'Not Empty' type guard
 * @param value
 */
export declare function notEmpty<TValue>(value: TValue | null | undefined | void): value is TValue;
export type Id<T> = {} & {
    [P in keyof T]: T[P];
};
export declare const crc16: (data: Buffer, initial: number) => number;
export declare const crc8: (data: Buffer, initial?: number) => number;
export declare const unpack: (props: Buffer | string, length: number, buffer: Buffer) => Promise<string>;
export declare const pack: (data: Buffer | string) => Promise<[string, Buffer]>;
export declare const isHorizontalConnection: (connectType: ScanBoardConnectTypeEnum) => connectType is ScanBoardConnectTypeEnum.LeftTop_Horizontal | ScanBoardConnectTypeEnum.LeftBottom_Horizontal | ScanBoardConnectTypeEnum.RightTop_Horizontal | ScanBoardConnectTypeEnum.RightBottom_Horizontal;
export declare const isTopConnection: (connectType: ScanBoardConnectTypeEnum) => connectType is ScanBoardConnectTypeEnum.LeftTop_Horizontal | ScanBoardConnectTypeEnum.RightTop_Horizontal | ScanBoardConnectTypeEnum.LeftTop_Vertical | ScanBoardConnectTypeEnum.RightTop_Vertical;
export declare const isLeftConnection: (connectType: ScanBoardConnectTypeEnum) => connectType is ScanBoardConnectTypeEnum.LeftTop_Horizontal | ScanBoardConnectTypeEnum.LeftBottom_Horizontal | ScanBoardConnectTypeEnum.LeftTop_Vertical | ScanBoardConnectTypeEnum.LeftBottom_Vertical;
export declare const minimax: (min: number, max: number, value: number) => number;
export type LEDDisplayInfo = SimpleLEDDisplayInfo | StandardLEDDisplayInfo | ComplexLEDDisplayInfo;
export declare const isSimpleScreen: (screen: LEDDisplayInfo) => screen is SimpleLEDDisplayInfo;
export declare const isStandardScreen: (screen: LEDDisplayInfo) => screen is StandardLEDDisplayInfo;
export declare const isComplexScreen: (screen: LEDDisplayInfo) => screen is ComplexLEDDisplayInfo;
type ExcludeUndefined<T> = {
    [P in keyof T]-?: Exclude<T[P], undefined>;
};
export declare const hasProps: <K extends string>(...props: K[]) => <T extends Partial<Record<K, unknown>>>(y: T) => y is T & ExcludeUndefined<Pick<T, K>> extends infer T_1 ? { [P in keyof T_1]: (T & ExcludeUndefined<Pick<T, K>>)[P]; } : never;
export declare const groupByProps: <K extends string>(...props: K[]) => <T extends Record<K, number>>(list: T[]) => [Record<K, number>, [T, ...T[]]][];
export declare const itFirstNotNull: <T>(it: AsyncIterable<T | null>) => Promise<T | null>;
export declare const itAll: <T>(it: AsyncIterable<T | null>) => Promise<(T | null)[]>;
export declare const toHex: (value: number) => string;
type FilterFlags<Base, Condition> = {
    [Key in keyof Base]: Base[Key] extends Condition ? Key : never;
};
export type AllowedNames<Base, Condition> = FilterFlags<Base, Condition>[keyof Base];
export {};
