"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const LEDDisplyType_1 = require("@novastar/native/LEDDisplyType");
const sortBy_1 = __importDefault(require("lodash/sortBy"));
/**
 * Nova.LCT.GigabitSystem.CommonInfoAccessor.dll
 *
 * Nova.LCT.GigabitSystem.CommonInfoAccessor::NewScreenDataConvertor::GetDeviceScreenData
 * @param screens
 */
function splitScreensByDevice(screens) {
    return (0, sortBy_1.default)(Object.entries(screens.reduce((acc, scr) => {
        switch (scr.ScrType) {
            case LEDDisplyType_1.LEDDisplyTypeEnum.SimpleSingleType: {
                if (typeof scr.DeviceID !== 'number')
                    throw new TypeError('Invalid DeviceID');
                const { [scr.DeviceID]: prev, ...other } = acc;
                return { [scr.DeviceID]: [...prev, scr], ...other };
            }
            case LEDDisplyType_1.LEDDisplyTypeEnum.StandardType:
            case LEDDisplyType_1.LEDDisplyTypeEnum.ComplexType: {
                const ids = scr.CabinetInDevice?.map(({ DevID }) => DevID).filter(DevID => DevID !== 255) ?? [];
                return (scr.CabinetInDevice ?? []).reduce((res, cab) => {
                    const key = (cab.DevID !== 255 ? cab.DevID : ids?.[0]) ?? 0;
                    const { [key]: prev, ...other } = res;
                    if (!prev)
                        return {
                            [key]: [
                                {
                                    ...scr,
                                    CabinetInDevice: [cab],
                                },
                            ],
                            ...other,
                        };
                    const copy = [...prev];
                    const found = copy.findIndex(item => item.UUID === scr.UUID);
                    if (found !== -1) {
                        const [item] = copy.splice(found, 1);
                        copy.splice(found, 0, {
                            ...item,
                            CabinetInDevice: item.CabinetInDevice ? [...item.CabinetInDevice, cab] : [cab],
                        });
                    }
                    else {
                        copy.push({
                            ...scr,
                            CabinetInDevice: [cab],
                        });
                    }
                    return {
                        [key]: copy,
                        ...other,
                    };
                }, acc);
            }
            default:
                throw new TypeError('Invalid screen type');
        }
    }, {})), ([index]) => index).map(([_, value]) => value);
}
exports.default = splitScreensByDevice;
//# sourceMappingURL=splitScreensByDevice.js.map