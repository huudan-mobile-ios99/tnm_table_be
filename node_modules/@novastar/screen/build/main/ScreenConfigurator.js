"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _ScreenConfigurator_ready, _ScreenConfigurator_devices, _ScreenConfigurator_screens, _ScreenConfigurator_dviInfo, _ScreenConfigurator_dviExtends, _ScreenConfigurator_reduList, _ScreenConfigurator_modulations, _ScreenConfigurator_dviVersion, _ScreenConfigurator_screenVersion;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllScanBoards = exports.AllPorts = exports.AllSenders = void 0;
const codec_1 = require("@novastar/codec");
const Connection_1 = __importDefault(require("@novastar/codec/Connection"));
const AddressMapping_1 = __importDefault(require("@novastar/native/AddressMapping"));
const BaudRateType_1 = require("@novastar/native/BaudRateType");
const LEDDisplyType_1 = require("@novastar/native/LEDDisplyType");
const PortScanBoardInfo_1 = require("@novastar/native/PortScanBoardInfo");
const ScreenDataInSoftSpace_1 = require("@novastar/native/ScreenDataInSoftSpace");
const SimpleLEDDisplayInfo_1 = require("@novastar/native/SimpleLEDDisplayInfo");
const SoftwareSpaceBaseAddress_1 = __importDefault(require("@novastar/native/SoftwareSpaceBaseAddress"));
const TestMode_1 = require("@novastar/native/TestMode");
const VirtualModeType_1 = require("@novastar/native/VirtualModeType");
const common_1 = require("@novastar/native/common");
const debug_1 = __importDefault(require("debug"));
const Either_1 = require("fp-ts/Either");
const t = __importStar(require("io-ts"));
const PathReporter_1 = require("io-ts/PathReporter");
const range_1 = __importDefault(require("lodash/range"));
const CommonCalculator_1 = require("./CommonCalculator");
const ConfigurationError_1 = __importDefault(require("./ConfigurationError"));
const CustomTransform_1 = require("./CustomTransform");
const DviScreenConfigInfo_1 = require("./DviScreenConfigInfo");
const FileInfo_1 = require("./FileInfo");
const GetScreenPortAddrInfo_1 = __importDefault(require("./GetScreenPortAddrInfo"));
const GetScreenSenderAddrInfo_1 = __importDefault(require("./GetScreenSenderAddrInfo"));
const HWAccessorCalculator_1 = require("./HWAccessorCalculator");
const HWStatus_1 = require("./HWStatus");
const ModulationInfo_1 = require("./ModulationInfo");
const RedundancyInfo_1 = require("./RedundancyInfo");
const ScreenConfigInfo_1 = require("./ScreenConfigInfo");
const Session_1 = __importDefault(require("./Session"));
const SoftwareSpaceHeader_1 = require("./SoftwareSpaceHeader");
const common_2 = require("./common");
const configs_1 = require("./configs");
const convertLEDDisplayInfoToScreenDataInSoftSpace_1 = __importDefault(require("./convertLEDDisplayInfoToScreenDataInSoftSpace"));
const convertScreenDataInSoftSpaceToLEDDisplayInfo_1 = __importDefault(require("./convertScreenDataInSoftSpaceToLEDDisplayInfo"));
const enumerator_1 = __importDefault(require("./enumerator"));
const getScreenLocation_1 = __importDefault(require("./getScreenLocation"));
const packAndSortCabinets_1 = __importDefault(require("./packAndSortCabinets"));
const splitScreensByDevice_1 = __importDefault(require("./splitScreensByDevice"));
const debug = (0, debug_1.default)('novastar:screen');
console.log('Hello from ScreenConfigurator');
debug('Hello from ScreenConfigurator');
exports.AllSenders = 0xff;
exports.AllPorts = 0xff;
exports.AllScanBoards = 0xffff;
// const DVIDataVer = 1001;
// const ScrAdjustParamsVer = 1002;
/**
 * RedundancyInfoAccessor
 */
// const ReduHeaderInfoLen = 10;
/**
 * SenderModulationInfoAccessor
 */
const ParamAddress = 83886592;
const FileInfoCompressedAddress = 83887104;
const ScreenDataInSoftSpaceList = t.type({
    ScreenDataInSoftSpace: t.array(ScreenDataInSoftSpace_1.ScreenDataInSoftSpace),
});
const consolidateResults = (results) => results.every(res => res == null) ? null : results.every(res => res === codec_1.ErrorType.Succeeded);
const firstCreator = (genFactory) => (screen) => {
    const it = genFactory(screen);
    return (0, common_2.itFirstNotNull)(it);
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const identity = (value) => value;
/*
type AsyncGeneratorType<T> = T extends AsyncGenerator<infer R> ? R : never;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type GeneratorFactory = (...args: ReadonlyArray<any>) => AsyncGenerator<any>;

type FirstWrapper<T extends GeneratorFactory> = (
  ...args: Parameters<T>
) => Promise<AsyncGeneratorType<ReturnType<T>> | null>;

type FirstWrapperCreator = <T extends GeneratorFactory>(gen: T) => FirstWrapper<T>;

const first: FirstWrapperCreator = gen =>
  async (...args) => {
    const generator = gen(...args);
    for await (const res of generator) {
      if (res !== null) return res;
    }
    return null;
  };
*/
const stringConverter = (res) => {
    const end = Math.max(0, res.data.indexOf(0));
    return res.data.slice(0, end).toString();
};
// noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
/**
 *
 */
class ScreenConfigurator {
    constructor(arg) {
        /**
         * Find all connected devices in the current session/connection, read screen configurations.
         */
        this.reload = this.queue(this.reloadImpl);
        /**
         * Save screen configurations to devices.
         */
        this.save = this.queue(this.saveImpl);
        this.ReadHWStatus = this.createReadGenerator('ReadAllStatus', res => new HWStatus_1.HWStatus(res.data).toJSON());
        this.ReadReceivingCardMCURemarks = this.createReadGenerator('ReadScanner_McuProgramRemarks', stringConverter);
        this.ReadReceivingCardFPGARemarks = this.createReadGenerator('ReadScanner_FPGAProgramRemarks', stringConverter);
        this.ReadChipType = this.createReadGenerator('ReadDriverType', codec_1.decodeUIntLE);
        this.ReadFirstChipType = firstCreator(this.ReadChipType);
        this.WriteBrightness = this.createWriter('SetGlobalBrightness', percent => Math.ceil(((0, common_2.minimax)(0, 100, percent) * 255) / 100));
        this.ReadBrightness = this.createReadGenerator('ReadGlobalBrightness', res => Math.round(((0, codec_1.decodeUIntLE)(res) * 10000) / 255) / 100);
        this.ReadFirstBrightness = firstCreator(this.ReadBrightness);
        this.WriteDisplayMode = this.createWriter('SetSelfTestMode');
        this.ReadDisplayMode = this.createReadGenerator('ReadSelfTestMode', codec_1.decodeUIntLE);
        this.ReadFirstDisplayMode = firstCreator(this.ReadDisplayMode);
        this.ReadGamma = this.createReadGenerator('ReadGamma', res => (0, codec_1.decodeUIntLE)(res) / 10);
        this.ReadFirstGamma = firstCreator(this.ReadGamma);
        this.ReadRGBVBrightness = this.createReadGenerator('ReadAllBrightnessInfo', res => {
            const [overall, red, green, blue, vRed] = res.data;
            return {
                overall,
                red,
                green,
                blue,
                vRed,
            };
        });
        this.ReadFirstRGBVBrightness = firstCreator(this.ReadRGBVBrightness);
        this.WriteGamma = this.createWriter('SetGamma', gamma => (gamma * 10) & 0xff);
        this.ReadFirstFuncCardLightSensor = firstCreator(this.ReadAllFuncCardLightSensor.bind(this));
        this.ReadFuncCardLightSensor = this.queue(this.readFuncCardLightSensorImpl);
        _ScreenConfigurator_ready.set(this, Promise.resolve());
        _ScreenConfigurator_devices.set(this, []);
        _ScreenConfigurator_screens.set(this, []);
        _ScreenConfigurator_dviInfo.set(this, void 0);
        _ScreenConfigurator_dviExtends.set(this, void 0);
        _ScreenConfigurator_reduList.set(this, []);
        _ScreenConfigurator_modulations.set(this, []);
        _ScreenConfigurator_dviVersion.set(this, 0);
        _ScreenConfigurator_screenVersion.set(this, 0);
        this.session = (arg instanceof Connection_1.default ? new Session_1.default(arg) : arg);
        // this.session.Distribute_SetRebootAppFpgaProgram(0,0,0,true,0);
    }
    get devices() {
        return __classPrivateFieldGet(this, _ScreenConfigurator_devices, "f");
    }
    get screens() {
        return __classPrivateFieldGet(this, _ScreenConfigurator_screens, "f");
    }
    get reduList() {
        return __classPrivateFieldGet(this, _ScreenConfigurator_reduList, "f");
    }
    get modulations() {
        return __classPrivateFieldGet(this, _ScreenConfigurator_modulations, "f");
    }
    reset() {
        __classPrivateFieldSet(this, _ScreenConfigurator_devices, [], "f");
        __classPrivateFieldSet(this, _ScreenConfigurator_screens, [], "f");
        __classPrivateFieldSet(this, _ScreenConfigurator_dviInfo, undefined, "f");
        __classPrivateFieldSet(this, _ScreenConfigurator_dviExtends, undefined, "f");
        __classPrivateFieldSet(this, _ScreenConfigurator_screenVersion, 0, "f");
        __classPrivateFieldSet(this, _ScreenConfigurator_dviVersion, 0, "f");
        __classPrivateFieldSet(this, _ScreenConfigurator_reduList, [], "f");
        __classPrivateFieldSet(this, _ScreenConfigurator_modulations, [], "f");
    }
    /**
     * FormMain
     */
    GetScreenAllPort(screen, toRead = false) {
        if (!toRead && (screen === -1 || this.screens.length === 0))
            return [
                {
                    SenderIndex: exports.AllSenders,
                    PortIndex: exports.AllPorts,
                    ScanIndex: exports.AllScanBoards,
                },
            ];
        if (this.screens.length === 0)
            return [];
        const scr = this.screens[screen];
        if (!scr)
            throw new TypeError(`Invalid screen index: ${screen}`);
        const list = (0, GetScreenPortAddrInfo_1.default)(scr).flatMap(({ SenderIndex, PortIndex, MinConnectIndex, LoadScannerCount }) => {
            const { SlaveSenderIndex, SlavePortIndex } = this.reduList.find(item => item.MasterPortIndex === PortIndex && item.MasterSenderIndex === SenderIndex) ?? {};
            return toRead
                ? (0, range_1.default)(MinConnectIndex, MinConnectIndex + LoadScannerCount).map(ScanIndex => ({
                    SenderIndex,
                    PortIndex,
                    SlaveSenderIndex,
                    SlavePortIndex,
                    ScanIndex,
                }))
                : {
                    SenderIndex,
                    PortIndex,
                    SlaveSenderIndex,
                    SlavePortIndex,
                    ScanIndex: 0xffff,
                };
        });
        return toRead ? list.filter(({ SenderIndex }) => SenderIndex !== exports.AllSenders) : list;
    }
    async WriteRGBVBrightness({ overall, red, green, blue, vRed }, screen = 0) {
        const addresses = this.GetScreenAllPort(screen);
        const value = Buffer.from([overall, red, green, blue, vRed]);
        if (addresses.length === 0) {
            const req = new codec_1.Request(value, true);
            req.address = AddressMapping_1.default.AllBrightnessInfoAddr;
            req.deviceType = codec_1.DeviceType.ReceivingCard;
            req.destination = exports.AllSenders;
            req.port = exports.AllPorts;
            req.rcvIndex = exports.AllScanBoards;
            await this.session.connection.send(req);
            return true;
        }
        const results = await (0, codec_1.series)(addresses, async (address) => {
            const req = new codec_1.Request(value);
            req.address = AddressMapping_1.default.AllBrightnessInfoAddr;
            req.deviceType = codec_1.DeviceType.ReceivingCard;
            req.destination = address.SenderIndex;
            req.port = address.PortIndex;
            req.rcvIndex = address.ScanIndex;
            const res = await this.session.connection.trySend(req);
            return res && res.ack;
        });
        return consolidateResults(results);
    }
    async FactoryReset(screen = 0) {
        this.session.pushTimeout(60000);
        try {
            return this.session.trySetReturnFactoryValues(screen, 0);
        }
        finally {
            this.session.popTimeout();
        }
    }
    async SendRemoveDeadPixels() {
        const req = new codec_1.Request([2]);
        req.address = 16777374;
        req.deviceType = codec_1.DeviceType.ReceivingCard;
        req.destination = exports.AllSenders;
        req.port = exports.AllPorts;
        req.rcvIndex = exports.AllScanBoards;
        const res = await this.session.connection.trySend(req);
        return res && res.ack === codec_1.ErrorType.Succeeded;
    }
    async ReadHasDVISignalIn(device = 0) {
        const res = await this.session.tryReadIsHasDVI(device);
        return res && res.ack === 0 && res.data[0] !== 0;
    }
    async *ReadAllFuncCardLightSensor() {
        const { portCount = 2 } = this.devices[0] ?? [];
        for (let PortIndex = 0; PortIndex < portCount; PortIndex += 1) {
            yield this.ReadFuncCardLightSensor(0, PortIndex, 0);
        }
    }
    async readFuncCardLightSensorImpl(senderIndex = 0, portIndex = 0, cardIndex = 0) {
        const data = Buffer.from([
            cardIndex,
            BaudRateType_1.BaudRateTypeEnum.BT_115200bps,
            0,
            0,
            0x55,
            0xaa,
            1,
            2,
            0x80,
            0xff,
            0x81,
        ]);
        const req = new codec_1.Request(data);
        req.address = AddressMapping_1.default.FuncCard_WriteOutDeviceAddr;
        req.deviceType = codec_1.DeviceType.FunctionCard;
        req.destination = senderIndex;
        req.port = portIndex;
        req.rcvIndex = cardIndex;
        let res = await this.session.connection.trySend(req);
        if (!res || res.ack !== 0)
            return null;
        res = await this.session.tryFuncCard_ReadOutDeviceValue_1(senderIndex, portIndex, cardIndex);
        if (!res ||
            res.ack !== 0 ||
            res.data.length !== 5 ||
            res.data[0] !== 1 ||
            res.data[1] !== 2 ||
            (0, common_2.crc8)(res.data.slice(1, -1)) !== res.data[4] ||
            (res.data[2] & 0x80) === 0)
            return null;
        return (((res.data[2] & 0x7f) << 8) + res.data[3]) * 2;
    }
    createReadGenerator(name, decoder) {
        return {
            async *[name](screen = 0) {
                const addresses = this.GetScreenAllPort(screen, true);
                for (const address of addresses) {
                    const { SenderIndex, PortIndex, ScanIndex } = address;
                    yield this.session[`try${name}`](SenderIndex, PortIndex, ScanIndex).then(res => !res || res.ack !== 0 ? null : decoder(res));
                }
            },
        }[name].bind(this);
    }
    createWriter(name, encoder = identity) {
        return {
            async [name](value, screen = -1) {
                const addresses = this.GetScreenAllPort(screen);
                // debug(`addresses: ${JSON.stringify(addresses)}`);
                const val = encoder(value);
                const results = await (0, codec_1.series)(addresses, ({ SenderIndex, PortIndex, ScanIndex }) => this.session[`try${name}`](SenderIndex, PortIndex, ScanIndex, val));
                return consolidateResults(results);
            },
        }[name].bind(this);
    }
    queue(func) {
        return (...args) => new Promise((resolve, reject) => {
            __classPrivateFieldSet(this, _ScreenConfigurator_ready, __classPrivateFieldGet(this, _ScreenConfigurator_ready, "f").finally().then(() => func.apply(this, args).then(resolve, reject)), "f");
        });
    }
    /**
     * ScreenInfoAccessor::LoadDviScreenInfoFromHW
     * NovaLCT::FormMain::OnEquipmentChangeEvent
     */
    async reloadImpl() {
        this.reset();
        __classPrivateFieldSet(this, _ScreenConfigurator_devices, await (0, enumerator_1.default)(this.session), "f");
        debug(`devices: ${JSON.stringify(this.devices)}`);
        if (this.devices.length > 1)
            throw new Error('An unexpected number of devices!');
        await (0, codec_1.series)(this.devices, async ({ maxPackageSize, model }, index) => {
            if (!(0, CustomTransform_1.IsSystemController)(model))
                return;
            this.session.connection.maxLength = maxPackageSize;
            await this.readBase(index);
            await this.readRedundancy(index);
            await this.readModulation(index);
        });
    }
    // TODO: Not Impl
    /**
     * Nova.LCT.GigabitSystem.CommonInfoAccessor.dll
     *
     * Nova.LCT.GigabitSystem.CommonInfoAccessor::ScreenInfoAccessor::SaveDviScreenInfoToHW
     * @protected
     */
    async saveImpl() {
        // Only one device expected
        // SetScreenConfigFalg
        await (0, codec_1.series)(this.devices, async ({ maxPackageSize }, index) => {
            this.session.connection.maxLength = maxPackageSize;
            await this.session.SetSender_ScreenConfigFlagSpace(index, false, [85, 0]);
        });
        const items = (0, splitScreensByDevice_1.default)(this.screens.map(convertLEDDisplayInfoToScreenDataInSoftSpace_1.default));
        if (items.length !== this.devices.length)
            throw new Error('Invalid number of devices');
        // NewSoftSpaceBasicAccessor::CompressFile
        await (0, codec_1.series)(items, async (screens, index) => {
            const src = JSON.stringify(ScreenDataInSoftSpaceList.encode({
                ScreenDataInSoftSpace: screens,
            }));
            const [props, fileCompressDataArea] = await (0, common_2.pack)(src);
            const info = {
                FileType: FileInfo_1.ScreenFileType,
                Version: FileInfo_1.ScreenFileVersion,
                Addr: FileInfo_1.FILE_COMPRESS_AREA_START_ADDR,
                SrcLength: src.length,
                DestLength: fileCompressDataArea.length,
                DecompressProps: props,
                CheckSum: (0, common_2.crc16)(fileCompressDataArea, 0x55aa),
            };
            // NewSoftSpaceBasicAccessor::CompressFileInfo
            const srcInfo = Buffer.from(JSON.stringify({
                SectionFormat: [info],
            }));
            const [infoProps, fileInfoCompressDataArea] = await (0, common_2.pack)(srcInfo);
            const nonCompressDataArea = Buffer.alloc(SoftwareSpaceHeader_1.ParamSize);
            nonCompressDataArea.writeUInt16LE(infoProps.length);
            nonCompressDataArea.write(infoProps, 2, 'binary');
            // NewSoftSpaceBasicAccessor::ConstructSpaceHeader
            const ss = new SoftwareSpaceHeader_1.SoftwareSpaceHeader();
            ss.header = SoftwareSpaceHeader_1.SoftwareSpaceHeaderFlag;
            ss.version = SoftwareSpaceHeader_1.SoftwareSpaceHeaderVersion;
            ss.paramSize = SoftwareSpaceHeader_1.ParamSize;
            ss.paramCRC = (0, common_2.crc16)(nonCompressDataArea, 0x55aa);
            ss.compressedSize = fileInfoCompressDataArea.length;
            ss.fileInfoSize = srcInfo.length;
            ss.fileInfoCRC = (0, common_2.crc16)(fileInfoCompressDataArea, 0x55aa);
            const raw = SoftwareSpaceHeader_1.SoftwareSpaceHeader.raw(ss);
            ss.crc = (0, common_2.crc16)(raw.slice(SoftwareSpaceHeader_1.SoftwareSpaceHeader.getOffsetOf('crc') + 2), 0x55aa);
            const spaceData = Buffer.alloc(0x2000 + fileCompressDataArea.length);
            raw.copy(spaceData);
            nonCompressDataArea.copy(spaceData, 512);
            fileInfoCompressDataArea.copy(spaceData, 1024);
            fileCompressDataArea.copy(spaceData, 0x2000);
            await this.WriteData(index, AddressMapping_1.default.Sender_SoftwareSpaceAddr, spaceData);
        });
    }
    async saveRedundancy(index) {
        const data = (0, RedundancyInfo_1.encodeRedundancyInfo)(this.reduList);
        await this.session.SetSender_SoftwareSpace(index, false, data, data.length, SoftwareSpaceBaseAddress_1.default.REDUNDANCY_BASE_ADDRESS);
    }
    // ScannerPropertyAccessor
    async sendParametersToScanBoardGroupImpl(scanBdProperty, isSmartMode = false, isSmartNoSend = true, senderIndex = 255, portIndex = 255, scanBdIndex = 0xffff) {
        if (!(0, CommonCalculator_1.isValidScanBdProp)(scanBdProperty))
            throw new TypeError('Invalid ScanBoardProperty');
        const copy = { ...scanBdProperty };
        const { StandardLedModuleProp, Support22BitModel } = scanBdProperty;
        if (!(0, CommonCalculator_1.isValidStandardLedModuleProp)(StandardLedModuleProp))
            throw new TypeError('Invalid StandardLedModuleProp');
        const { ScreenDriveType, DriverChipType } = StandardLedModuleProp;
        // ChipDataMaker.GetChipInfo <- skipped (2053)
        if (!isSmartMode) {
            await this.session.SetSelfTestMode(senderIndex, portIndex, scanBdIndex, false, TestMode_1.TestModeEnum.ParaFreeze);
            await (0, codec_1.delay)(1000);
        }
        // ScannerPropertyDataProcess.Instance.ScanBdPropertyExchanged <- skipped
        if (Support22BitModel) {
            await this.session.SetScannerxBitEnable(senderIndex, portIndex, scanBdIndex, false, 100);
            await (0, codec_1.delay)(100);
        }
        const autoRefreshRates = (0, HWAccessorCalculator_1.GetAutoRefreshRateBytesSeq)((0, HWAccessorCalculator_1.SetVariousScanBdRefreshRate)(scanBdProperty, isSmartMode));
        await this.session.SetScanner_AutoRefreshRate(senderIndex, portIndex, scanBdIndex, false, autoRefreshRates);
        const smartMode = (0, CustomTransform_1.GetSmartMode)(isSmartMode, ScreenDriveType, DriverChipType);
        await this.session.SetSmartSetMode(senderIndex, portIndex, scanBdIndex, false, smartMode);
        copy.IsEnableOtherRefreshNumParams = !isSmartMode;
    }
    /**
     * Nova.LCT.GigabitSystem.LEDConfigAccessor
     *
     * Nova.LCT.GigabitSystem.HWConfigAccessor::PollingScannerParam
     *
     * ScannerPropertyAccessor::StartPollingScannerAccessor
     * @constructor
     * @protected
     */
    async ExecuteCheck(req) {
        const { destination, port, rcvIndex } = req;
        let attempts = 20;
        while (attempts > 0) {
            // ReadRegisterState
            // eslint-disable-next-line no-await-in-loop
            const res = await this.session.tryReadScannerFunctionInfo(destination, port, rcvIndex);
            if (res)
                return;
            attempts -= 1;
            // eslint-disable-next-line no-await-in-loop
            if (attempts)
                await (0, codec_1.delay)(400);
        }
        throw new Error('Hardware timeout');
    }
    /**
     * Nova.LCT.GigabitSystem.CommonInfoAccessor, RedundancyInfoAccessor
     */
    async readRedundancy(index) {
        const info = new RedundancyInfo_1.RedundancyInfo(await this.session.ReadSender_SoftwareSpace(index, RedundancyInfo_1.RedundancyInfo.baseSize, SoftwareSpaceBaseAddress_1.default.REDUNDANCY_BASE_ADDRESS));
        debug(`redundancyHeader: ${info.header} (${info.length})`);
        if (info.header !== RedundancyInfo_1.ReduFlag || info.length === 0)
            return;
        const data = await this.session.ReadSender_SoftwareSpace(index, RedundancyInfo_1.RedundancyInfo.baseSize + info.length, SoftwareSpaceBaseAddress_1.default.REDUNDANCY_BASE_ADDRESS);
        __classPrivateFieldSet(this, _ScreenConfigurator_reduList, (0, RedundancyInfo_1.decodeRedundancyInfo)(data), "f");
        debug(`redundancy: ${JSON.stringify(this.reduList)}`);
    }
    async readModulation(index = 0) {
        const data = await this.session.ReadSender_SoftwareSpace(index, ModulationInfo_1.ModulationInfoHeader.baseSize, SoftwareSpaceBaseAddress_1.default.MODULATION_BASE_ADDRESS);
        const header = new ModulationInfo_1.ModulationInfoHeader(data);
        if (header.header !== ModulationInfo_1.SenderModulationFlag || header.length === 0)
            return;
        const total = header.length + ModulationInfo_1.ModulationInfoHeader.baseSize;
        const buf = await this.session.ReadSender_SoftwareSpace(0, total, SoftwareSpaceBaseAddress_1.default.MODULATION_BASE_ADDRESS);
        __classPrivateFieldSet(this, _ScreenConfigurator_modulations, (0, ModulationInfo_1.decodeModulationInfo)(buf), "f");
        debug(`modulations: ${JSON.stringify(this.modulations)}`);
    }
    async saveModulation(index) {
        const data = (0, ModulationInfo_1.encodeModulationInfo)(this.modulations);
        await this.session.SetSender_SoftwareSpace(index, false, data, data.length, SoftwareSpaceBaseAddress_1.default.MODULATION_BASE_ADDRESS);
    }
    async readBase(index) {
        debug(`try readBase:${index}`);
        const spaceHeader = await this.session.ReadSender_SoftwareSpace(index, 512, // HEADER_LENGTH
        SoftwareSpaceBaseAddress_1.default.BASE_ADDRESS);
        /**
         * ScreenInfoAccessor::OnReadSpaceTypeCompleted
         */
        const header = spaceHeader.slice(0, 4).toString('ascii');
        debug(`readBase: ${header}`);
        switch (header) {
            case 'NSSD': // after sendConfig;
                return this.ReadSoftSpaceData(spaceHeader, index);
            case DviScreenConfigInfo_1.DviScreenInfoFlag:
                return this.ReadDviScreenInfo(spaceHeader, index);
            case '\x00\x00\x00\x00': // Quick Config
                return this.ReadSenderScreenConfigInfo(index);
            default:
                throw new TypeError('Unknown header type');
        }
    }
    /**
     * Nova.GigabitController.FrmSysConfigMode
     */
    async SetScreenALLWidth() {
        const results = await (0, codec_1.series)(this.screens, scr => {
            const location = (0, getScreenLocation_1.default)(scr);
            const senders = (0, GetScreenSenderAddrInfo_1.default)(scr);
            return (0, codec_1.series)(senders, ({ SenderIndex }) => this.session.trySetSenderVideoEnclosingMode(SenderIndex, location.rightBottom.x, location.rightBottom.y));
        });
        return consolidateResults(results.flat(1));
    }
    async ReadDviScreenInfo(header, index) {
        debug(`${DviScreenConfigInfo_1.DviScreenInfoFlag}: ReadDviScreenInfo`);
        if (header.length < DviScreenConfigInfo_1.DviScreenConfigInfo.baseSize)
            throw new TypeError('Invalid DviScreenConfigInfo header length');
        const dsci = new DviScreenConfigInfo_1.DviScreenConfigInfo(header.slice(0, DviScreenConfigInfo_1.DviScreenConfigInfo.baseSize));
        const { dviInfoLength, screenInfoLength, adjustInfoLength } = dsci;
        const data = await this.session.ReadSender_SoftwareSpace(index, DviScreenConfigInfo_1.DviScreenConfigInfo.baseSize + dviInfoLength + screenInfoLength + adjustInfoLength, SoftwareSpaceBaseAddress_1.default.BASE_ADDRESS);
        const { screens, dviVersion, dviInfo, dviExtends } = (0, configs_1.decodeScreenConfig)(data);
        __classPrivateFieldSet(this, _ScreenConfigurator_screens, screens, "f");
        __classPrivateFieldSet(this, _ScreenConfigurator_dviVersion, dviVersion, "f");
        __classPrivateFieldSet(this, _ScreenConfigurator_dviInfo, dviInfo, "f");
        __classPrivateFieldSet(this, _ScreenConfigurator_dviExtends, dviExtends, "f");
        // if (crc(data, crc(DviScreenConfigInfo.raw(dsci).slice(6), 0)) !== crcInfo)
        //   throw new Error(`Invalid DviScreenConfigInfo crc`);
        // [this.#dviInfo, this.#dviVersion] = parseGraphicsDVIPortInfo(data.slice(0, dviInfoLength));
        // debug(`dviInfo: ${JSON.stringify(this.#dviInfo)}`);
        // debug(`dviVersion: ${this.#dviVersion}`);
        // [this.#screens, this.#screenVersion] = parseScreenInfo(
        //   data.slice(dviInfoLength, dviInfoLength + screenInfoLength)
        // );
        // const adjustInfo = parseScreenAdjustInfo(data.slice(dviInfoLength + screenInfoLength));
        // if (adjustInfo.length > 0) {
        //   if (adjustInfo.length !== this.screens.length) throw new Error('Invalid adjust info
        // count'); this.#screens = this.#screens.map(({ ScrAdjustParams, ...other }, i) => ({
        // ...other, ScrAdjustParams: adjustInfo[i], })); } debug(`screens:
        // ${JSON.stringify(this.#screens)}`);
    }
    async ReadSenderScreenConfigInfo(index) {
        debug('0000: ReadSenderScreenConfigInfo');
        const res = await this.session.tryReadSender_ScreenConfigSpace(index);
        if (!res)
            return;
        const { Type, ScanBdCols, ScanBdRows, CabinetsPerPort, PixelColsInScanBd, PixelRowsInScanBd, ConnectType, X, Y, } = new ScreenConfigInfo_1.ScreenConfigInfo(res.data);
        switch (Type) {
            case 1: {
                if (!ScanBdCols || !ScanBdRows || !CabinetsPerPort)
                    throw new Error('Invalid screen cfg');
                const total = ScanBdRows * ScanBdCols;
                const portCount = Math.ceil(total / CabinetsPerPort);
                if (CabinetsPerPort % ((0, common_2.isHorizontalConnection)(ConnectType) ? ScanBdCols : ScanBdRows) !== 0)
                    throw new ConfigurationError_1.default('Invalid cabinetsPerPort');
                let portCols = 0;
                let portRows = 0;
                let ports = [];
                if ((0, common_2.isHorizontalConnection)(ConnectType)) {
                    portCols = 1;
                    portRows = portCount;
                    const getRow = (row) => (0, common_2.minimax)(0, ScanBdRows, (0, common_2.isTopConnection)(ConnectType) ? row : ScanBdRows - row);
                    const rowsPerPort = CabinetsPerPort / ScanBdCols;
                    ports = (0, range_1.default)(portCount).map(PortIndex => {
                        const extremes = [
                            getRow(PortIndex * rowsPerPort),
                            getRow((PortIndex + 1) * rowsPerPort),
                        ];
                        return (0, common_1.makeStruct)(PortScanBoardInfo_1.PortScanBoardInfo, {
                            PortIndex,
                            ConnectType,
                            ScanBdBegColNo: 0,
                            ScanBdEndColNo: ScanBdCols,
                            ScanBdBegRowNo: Math.min(...extremes),
                            ScanBdEndRowNo: Math.max(...extremes),
                        });
                    });
                }
                else {
                    portCols = portCount;
                    portRows = 1;
                    const getCol = (col) => (0, common_2.minimax)(0, ScanBdCols, (0, common_2.isLeftConnection)(ConnectType) ? col : ScanBdCols - col);
                    const colsPerPort = CabinetsPerPort / ScanBdRows;
                    ports = (0, range_1.default)(portCount).map(PortIndex => {
                        const extremes = [
                            getCol(PortIndex * colsPerPort),
                            getCol((PortIndex + 1) * colsPerPort),
                        ];
                        return (0, common_1.makeStruct)(PortScanBoardInfo_1.PortScanBoardInfo, {
                            PortIndex,
                            ConnectType,
                            ScanBdBegRowNo: 0,
                            ScanBdEndRowNo: ScanBdRows,
                            ScanBdBegColNo: Math.min(...extremes),
                            ScanBdEndColNo: Math.max(...extremes),
                        });
                    });
                }
                __classPrivateFieldSet(this, _ScreenConfigurator_screens, [
                    (0, common_1.makeStruct)(SimpleLEDDisplayInfo_1.SimpleLEDDisplayInfo, {
                        Type: LEDDisplyType_1.LEDDisplyTypeEnum.SimpleSingleType,
                        PixelColsInScanBd,
                        PixelRowsInScanBd,
                        ScanBdCols,
                        ScanBdRows,
                        PortCols: portCols,
                        PortRows: portRows,
                        SenderIndex: 0,
                        X,
                        Y,
                        VirtualMode: VirtualModeType_1.VirtualModeTypeEnum.Disable,
                        PortScanBdInfoList: ports,
                    }),
                ], "f");
                break;
            }
            case 3: {
                if (__classPrivateFieldGet(this, _ScreenConfigurator_screens, "f").length === 1) {
                    const [screen] = __classPrivateFieldGet(this, _ScreenConfigurator_screens, "f");
                    if ((0, common_2.isSimpleScreen)(screen) && common_1.UInt16.is(X) && common_1.UInt16.is(Y)) {
                        screen.X = X;
                        screen.Y = Y;
                    }
                }
                break;
            }
            case 5:
                break;
            default:
                throw new TypeError('Invalid screen config type');
        }
        debug(`screens: ${JSON.stringify(this.screens)}`);
    }
    async ReadData(index, address, length) {
        const req = new codec_1.Request(length);
        req.address = address;
        req.destination = index;
        const { data } = await this.session.connection.send(req);
        return data;
    }
    async WriteData(index, address, data) {
        const req = new codec_1.Request(data);
        req.address = address;
        req.destination = index;
        await this.session.connection.send(req);
    }
    async ReadSoftSpaceData(spaceHeader, index) {
        debug('NSSD: ReadSoftSpaceData');
        const ss = new SoftwareSpaceHeader_1.SoftwareSpaceHeader(spaceHeader);
        if ((0, common_2.crc16)(spaceHeader.slice(SoftwareSpaceHeader_1.SoftwareSpaceHeader.getOffsetOf('crc') + 2), 0x55aa) !== ss.crc)
            throw new Error('Invalid space header crc');
        if (ss.paramSize !== SoftwareSpaceHeader_1.ParamSize)
            throw new Error('Invalid uncompressedSize');
        const paramData = await this.ReadData(index, ParamAddress, ss.paramSize);
        if (ss.paramCRC !== (0, common_2.crc16)(paramData, 0x55aa))
            throw new Error('Param crc error');
        const fileInfoCompressData = await this.ReadData(index, FileInfoCompressedAddress, ss.compressedSize);
        if (ss.fileInfoCRC !== (0, common_2.crc16)(fileInfoCompressData, 0x55aa))
            throw new Error('FileInfoCRC error');
        const fileInfoListV = FileInfo_1.FileInfoObjectList.decode(JSON.parse(await (0, common_2.unpack)(paramData.slice(2), ss.fileInfoSize, fileInfoCompressData)));
        if ((0, Either_1.isLeft)(fileInfoListV))
            throw new Error(`Invalid fileInfoList: ${PathReporter_1.PathReporter.report(fileInfoListV)}`);
        const fileInfoList = fileInfoListV.right;
        debug(`fileInfoList: ${JSON.stringify(fileInfoList)}`);
        // console.log(inspect(fileInfoList, false, null));
        const screens = (await (0, codec_1.series)(fileInfoList.SectionFormat, async (info) => {
            const fi = await this.ReadData(index, info.Addr, info.DestLength);
            const list = JSON.parse(await (0, common_2.unpack)(info.DecompressProps, info.SrcLength, fi));
            // console.log(inspect(list, false, null));
            const screenListV = ScreenDataInSoftSpaceList.decode(list);
            if ((0, Either_1.isLeft)(screenListV)) {
                console.error(PathReporter_1.PathReporter.report(screenListV));
                throw new Error('Invalid screenList');
            }
            // console.log('screenList:', inspect(screenListV.right, false, null));
            return (0, packAndSortCabinets_1.default)(screenListV.right.ScreenDataInSoftSpace, index);
        })).flat(1);
        // console.log('packed:', screensByDevices.length, inspect(screensByDevices, false, null));
        __classPrivateFieldSet(this, _ScreenConfigurator_screens, screens.map(convertScreenDataInSoftSpaceToLEDDisplayInfo_1.default), "f");
        debug(`screens: ${JSON.stringify(this.screens)}`);
        // console.log('screens:', inspect(this.#screens, false, null));
        // this.screens.forEach((screen, i) => {
        //   console.log('ports', inspect(GetScreenPortAddrInfo(screen), false, null));
        //   console.log('scr:', inspect(GetScreenSenderAddrInfo(screen), false, null));
        //   console.log('all:', inspect(this.GetScreenAllPort(i), false, null));
        // });
    }
}
exports.default = ScreenConfigurator;
_ScreenConfigurator_ready = new WeakMap(), _ScreenConfigurator_devices = new WeakMap(), _ScreenConfigurator_screens = new WeakMap(), _ScreenConfigurator_dviInfo = new WeakMap(), _ScreenConfigurator_dviExtends = new WeakMap(), _ScreenConfigurator_reduList = new WeakMap(), _ScreenConfigurator_modulations = new WeakMap(), _ScreenConfigurator_dviVersion = new WeakMap(), _ScreenConfigurator_screenVersion = new WeakMap();
//# sourceMappingURL=ScreenConfigurator.js.map