"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeScannerBinData = exports.ScannerBinData = exports.ScannerBinDataFlag = void 0;
const typed_struct_1 = __importDefault(require("typed-struct"));
const ScanBdRecordNoSendParams_1 = require("./ScanBdRecordNoSendParams");
const common_1 = require("./common");
const findKnownAddresses_1 = __importDefault(require("./findKnownAddresses"));
exports.ScannerBinDataFlag = 'RCCB';
/**
 * RCCB
 */
exports.ScannerBinData = new typed_struct_1.default('ScannerBinData')
    .String('header', 'ascii', exports.ScannerBinDataFlag.length)
    .UInt32LE('length')
    .UInt16LE('crc')
    .UInt16LE('version', 1001)
    .seek(52)
    .Buffer('data')
    .compile();
const decodeScannerBinData = (buffer) => {
    const { header, crc: binCrc, length, data } = new exports.ScannerBinData(buffer);
    if (header !== exports.ScannerBinDataFlag)
        throw new Error('Invalid ScannerBinData header');
    if (length !== buffer.length)
        throw new Error('Invalid ScannerBinData length');
    if ((0, common_1.crc16)(data, 0x5555) !== binCrc)
        throw new Error('Invalid ScannerBinData CRC');
    const params = [];
    const dataLength = length - exports.ScannerBinData.baseSize;
    for (let offset = 0; offset < dataLength;) {
        const { address, data: paramData, delay, size, } = new ScanBdRecordNoSendParams_1.ScanBdRecordNoSendParams(data.slice(offset));
        const name = (0, findKnownAddresses_1.default)(address);
        params.push({
            address,
            data: Buffer.from(paramData.slice(0, size)),
            delay,
            name,
        });
        offset += size;
    }
    return params;
};
exports.decodeScannerBinData = decodeScannerBinData;
//# sourceMappingURL=ScannerBinData.js.map