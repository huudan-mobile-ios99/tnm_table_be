"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetAutoRefreshRateBytesSeq = exports.SetVariousScanBdRefreshRate = exports.CheckIsModeSupport = exports.GetRateFromRateType = exports.AllParameterNumberLen = exports.OneParameterLen = void 0;
// Nova.LCT.GigabitSystem.LEDConfigAccessorBase.dll
const AutoAdjustRefreshRateParameters_1 = require("@novastar/native/AutoAdjustRefreshRateParameters");
const AutoAdjustRefreshRateType_1 = require("@novastar/native/AutoAdjustRefreshRateType");
const ChipType_1 = require("@novastar/native/ChipType");
const MaxValue_1 = __importDefault(require("@novastar/native/MaxValue"));
const ScreenDriveType_1 = require("@novastar/native/ScreenDriveType");
const common_1 = require("@novastar/native/common");
const AutoRefreshRate_1 = require("./AutoRefreshRate");
const ChipInherentProperties_1 = require("./ChipInherentProperties");
const CommonCalculator_1 = require("./CommonCalculator");
const ScannerCapabilityICN2053_1 = __importDefault(require("./ScannerCapabilityICN2053"));
const common_2 = require("./common");
exports.OneParameterLen = 16;
exports.AllParameterNumberLen = 128;
const GetRateFromRateType = (rateType) => {
    let rateFromRateType;
    switch (rateType % 16) {
        case 0:
            rateFromRateType = 50;
            break;
        case 1:
            rateFromRateType = 60;
            break;
        case 2:
            rateFromRateType = 75;
            break;
        case 3:
            rateFromRateType = 120;
            break;
        case 4:
            rateFromRateType = 48;
            break;
        case 5:
            rateFromRateType = 30;
            break;
        case 6:
            rateFromRateType = 85;
            break;
        case 7:
            rateFromRateType = 100;
            break;
        case 8:
            rateFromRateType = 24;
            break;
        case 9:
            rateFromRateType = 72;
            break;
        case 10:
            rateFromRateType = 25;
            break;
        case 11:
            rateFromRateType = 240;
            break;
        case 12:
            rateFromRateType = 144;
            break;
        default:
            rateFromRateType = 60;
    }
    switch (rateType / 16) {
        case 1:
            rateFromRateType -= 0.05;
            break;
        case 2:
            rateFromRateType -= 0.1;
            break;
        case 3:
            rateFromRateType += 0.05;
            break;
        case 4:
            rateFromRateType += 0.1;
            break;
        case 5:
            rateFromRateType += 0.15;
            break;
        case 6:
            rateFromRateType += 0.2;
            break;
        case 7:
            rateFromRateType += 0.25;
            break;
        default:
            throw new TypeError('Invalid AutoAdjustRefreshRateTypeEnum');
    }
    return rateFromRateType;
};
exports.GetRateFromRateType = GetRateFromRateType;
const CheckIsModeSupport = (scanBdProperty, fieldRate) => {
    if (!(0, CommonCalculator_1.isValidScanBdProp)(scanBdProperty))
        throw new TypeError('Invalid ScanBoardProperty');
    const { StandardLedModuleProp, Width, Height } = scanBdProperty;
    if (!(0, CommonCalculator_1.isValidStandardLedModuleProp)(StandardLedModuleProp))
        throw new TypeError('Invalid StandardLedModuleProp');
    const { DriverChipType, ScreenDriveType, SerialColorNum } = StandardLedModuleProp;
    // ChipDataMaker.GetChipInfo <- skipped
    if (DriverChipType !== ChipType_1.ChipTypeEnum.Chip_ICN2053)
        throw new Error('Not implemented');
    const result = { ...scanBdProperty };
    const scanBoardCapability = new ScannerCapabilityICN2053_1.default();
    scanBoardCapability.UpdateParameters(result, fieldRate);
    const k = ScreenDriveType === ScreenDriveType_1.ScreenDriveTypeEnum.Serial ? SerialColorNum : 1;
    const { maxWidth, maxHeight } = (0, CommonCalculator_1.CaculateMaxloadSize)(result, scanBoardCapability.MaxLoadedPixels / k, MaxValue_1.default.MAX_SCANNER_AREA);
    result.TotalUnitNum = scanBoardCapability.TotalUnitNumPerSubField;
    result.TotalGclkUnitNumPerScan = scanBoardCapability.TotalGclkUnitNumPerScan;
    result.LightTime = scanBoardCapability.LightTimePerSubField;
    result.LightTimeNum2 = scanBoardCapability.LightTimeNum2;
    return [maxWidth >= Width && maxHeight >= Height, result];
};
exports.CheckIsModeSupport = CheckIsModeSupport;
const SetVariousScanBdRefreshRate = (scanBdProperty, isSmartMode) => {
    const { StandardLedModuleProp: { DriverChipType: chipType, ScanType: scanType } = {} } = scanBdProperty;
    if (chipType === undefined || scanType === undefined)
        throw new TypeError('Invalid ScanBoardProperty');
    return Object.values(AutoAdjustRefreshRateType_1.AutoAdjustRefreshRateTypeEnum)
        .map(Number)
        .filter(common_2.notEmpty)
        .map(rateType => {
        let prop;
        const rateFromRateType = (0, exports.GetRateFromRateType)(rateType);
        if (!isSmartMode) {
            if ((0, ChipInherentProperties_1.CanManualAdjustRefreshRate)(chipType, scanType)) {
                throw new Error('Not implemented');
            }
            const [isSupport, res] = (0, exports.CheckIsModeSupport)(scanBdProperty, rateFromRateType);
            if (isSupport || res.TotalUnitNum - 3 >= res.ShiftUnitNum)
                prop = res;
        }
        const { TotalUnitNum, TotalGclkUnitNumPerScan, RefNumPerVs, GCLKRate, IsEnableTranCntNum, M1TranCntNum, M2TranCntNum, LightTime, LightTimeNum2, } = prop ?? scanBdProperty;
        return (0, common_1.makeStruct)(AutoAdjustRefreshRateParameters_1.AutoAdjustRefreshRateParameters, {
            AdjustRateType: rateType,
            TotalUnitNum,
            TotalGclkUnitNumPerScan,
            RefNumPerVs,
            GCLKRate,
            IsEnableTranCntNum,
            M1TranCntNum,
            M2TranCntNum,
            LightTime,
            LightTimeNum2,
        });
    });
};
exports.SetVariousScanBdRefreshRate = SetVariousScanBdRefreshRate;
const GetAutoRefreshRateBytesSeq = (autoRateParamList) => {
    const buffer = Buffer.alloc(exports.OneParameterLen * exports.AllParameterNumberLen);
    autoRateParamList.forEach(({ AdjustRateType, ...props }) => {
        const data = new AutoRefreshRate_1.AutoRefreshRate(exports.OneParameterLen);
        Object.assign(data, props);
        AutoRefreshRate_1.AutoRefreshRate.raw(data).copy(buffer, AdjustRateType * exports.OneParameterLen);
    });
    return buffer;
};
exports.GetAutoRefreshRateBytesSeq = GetAutoRefreshRateBytesSeq;
//# sourceMappingURL=HWAccessorCalculator.js.map