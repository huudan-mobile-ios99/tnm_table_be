"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toHex = exports.itAll = exports.itFirstNotNull = exports.groupByProps = exports.hasProps = exports.isComplexScreen = exports.isStandardScreen = exports.isSimpleScreen = exports.minimax = exports.isLeftConnection = exports.isTopConnection = exports.isHorizontalConnection = exports.pack = exports.unpack = exports.crc8 = exports.crc16 = exports.notEmpty = void 0;
/* eslint-disable no-bitwise */
const lzma_1 = require("@sarakusha/lzma");
const LEDDisplyType_1 = require("@novastar/native/LEDDisplyType");
const ScanBoardConnectType_1 = require("@novastar/native/ScanBoardConnectType");
const groupBy_1 = __importDefault(require("lodash/groupBy"));
/**
 * 'Not Empty' type guard
 * @param value
 */
function notEmpty(value) {
    return (value !== undefined && value !== null && (typeof value !== 'number' || !Number.isNaN(value)));
}
exports.notEmpty = notEmpty;
const crc16 = (data, initial) => data.reduce((acc, value) => (acc + value) & 0xffff, initial);
exports.crc16 = crc16;
const crc8 = (data, initial = 0) => data.reduce((acc, value) => (acc + value) & 0xff, initial);
exports.crc8 = crc8;
/*
props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);

SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
{
  UInt32 dicSize;
  Byte d;

  if (size < LZMA_PROPS_SIZE)
    return SZ_ERROR_UNSUPPORTED;
  else
    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);

  if (dicSize < LZMA_DIC_MIN)
    dicSize = LZMA_DIC_MIN;
  p->dicSize = dicSize;

  d = data[0];
  if (d >= (9 * 5 * 5))
    return SZ_ERROR_UNSUPPORTED;

  p->lc = (Byte)(d % 9);
  d /= 9;
  p->pb = (Byte)(d / 5);
  p->lp = (Byte)(d % 5);

  return SZ_OK;
}
 */
const unpack = (props, length, buffer) => {
    const propsBuf = Buffer.isBuffer(props) ? props : Buffer.from(props, 'binary');
    if (propsBuf.length !== 5)
        throw new TypeError('Invalid props length');
    const lengthBuf = Buffer.alloc(8);
    if (length === -1)
        lengthBuf.fill(0xff);
    else
        lengthBuf.writeUInt32LE(length);
    const data = Buffer.concat([propsBuf, lengthBuf, buffer]);
    return new Promise((resolve, reject) => {
        (0, lzma_1.decompress)(data, (res, err) => {
            if (res)
                resolve(Buffer.from(res).toString());
            else
                reject(err);
        });
    });
};
exports.unpack = unpack;
const pack = async (data) => {
    const compressed = await new Promise((resolve, reject) => {
        (0, lzma_1.compress)(data, 8, (res, err) => {
            if (res)
                resolve(Buffer.from(res));
            else
                reject(err);
        });
    });
    return [compressed.slice(0, 5).toString('binary'), compressed.slice(5 + 8)];
};
exports.pack = pack;
const isHorizontalConnection = (connectType) => connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.LeftTop_Horizontal ||
    connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.LeftBottom_Horizontal ||
    connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.RightTop_Horizontal ||
    connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.RightBottom_Horizontal;
exports.isHorizontalConnection = isHorizontalConnection;
const isTopConnection = (connectType) => connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.LeftTop_Horizontal ||
    connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.RightTop_Horizontal ||
    connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.LeftTop_Vertical ||
    connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.RightTop_Vertical;
exports.isTopConnection = isTopConnection;
const isLeftConnection = (connectType) => connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.LeftTop_Horizontal ||
    connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.LeftTop_Vertical ||
    connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.LeftBottom_Horizontal ||
    connectType === ScanBoardConnectType_1.ScanBoardConnectTypeEnum.LeftBottom_Vertical;
exports.isLeftConnection = isLeftConnection;
const minimax = (min, max, value) => Math.min(Math.max(value, min), max);
exports.minimax = minimax;
const isSimpleScreen = (screen) => screen.Type === LEDDisplyType_1.LEDDisplyTypeEnum.SimpleSingleType;
exports.isSimpleScreen = isSimpleScreen;
const isStandardScreen = (screen) => screen.Type === LEDDisplyType_1.LEDDisplyTypeEnum.StandardType;
exports.isStandardScreen = isStandardScreen;
const isComplexScreen = (screen) => screen.Type === LEDDisplyType_1.LEDDisplyTypeEnum.ComplexType;
exports.isComplexScreen = isComplexScreen;
const hasProps = (...props) => (y) => notEmpty(y) && props.reduce((acc, name) => acc && notEmpty(y[name]), true);
exports.hasProps = hasProps;
const zipProps = (props) => (item) => props.map(name => item[name]).join(':');
const unzipProps = (props, key) => key
    .split(':')
    .map(Number)
    .reduce((acc, value, i) => ({
    ...acc,
    [props[i]]: value,
}), {});
const groupByProps = (...props) => (list) => Object.entries((0, groupBy_1.default)(list, zipProps(props))).map(([key, items]) => [unzipProps(props, key), items]);
exports.groupByProps = groupByProps;
const itFirstNotNull = async (it) => {
    for await (const res of it) {
        if (res !== null)
            return res;
    }
    return null;
};
exports.itFirstNotNull = itFirstNotNull;
const itAll = async (it) => {
    const all = [];
    for await (const res of it) {
        all.push(res);
    }
    return all;
};
exports.itAll = itAll;
const toHex = (value) => {
    const hex = value.toString(16);
    const pos = hex.length - 4;
    return pos > 0 ? `0x${hex.slice(0, pos)}_${hex.slice(pos)}` : `${value > 9 ? '0x' : ''}${hex}`;
};
exports.toHex = toHex;
//# sourceMappingURL=common.js.map