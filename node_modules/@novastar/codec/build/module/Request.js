import { COMPUTER, IO, isPacket, Packet, REQUEST } from './Packet';
const isLikeNumberArray = (value) => Buffer.isBuffer(value) ||
    (Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number'));
const createArgs = (param) => {
    if (isPacket(param))
        return [Packet.raw(param), true];
    const raw = Buffer.alloc(Packet.baseSize + (isLikeNumberArray(param) ? param.length : 0));
    return [raw, undefined];
};
const dataOffset = Packet.getOffsetOf('data');
/**
 * Custom request prepared for sending to Novastar devices
 */
export default class Request extends Packet {
    static counter = 0;
    /**
     * If this is true, then do not wait for a response from the device
     */
    broadcast;
    /**
     * Overriding the timeout for this request
     */
    timeout;
    /**
     * Overriding the maximum data length for this request
     */
    maxLength;
    /**
     * Preserves the size of the original request if it exceeds 65535.
     */
    originalLength;
    /**
     * For debugging and describing exceptions
     */
    tag;
    constructor(param, param2, param3) {
        super(...createArgs(param));
        const broadcast = typeof param2 === 'boolean' ? param2 : undefined;
        this.tag = typeof param2 === 'string' ? param2 : param3;
        if (!isPacket(param)) {
            this.head = REQUEST;
            this.source = COMPUTER;
            this.broadcast = broadcast;
            if (isLikeNumberArray(param)) {
                this.io = IO.Write;
                Buffer.from(param).copy(this.data);
                this.length = param.length;
                this.originalLength = param.length;
            }
            else {
                this.io = IO.Read;
                this.length = param;
                this.originalLength = param;
            }
        }
        else if (param instanceof Request) {
            this.broadcast = param.broadcast;
            this.timeout = param.timeout;
            this.maxLength = param.maxLength;
            this.originalLength = param.originalLength;
            this.tag = param.tag;
        }
        this.serno = Request.next();
    }
    /**
     * Split the original request into chunks with the specified maximum data length
     * @param req - original request
     * @param maxLength - maximum data length
     * @returns - chunks
     */
    static makeChunks(req, maxLength = 256) {
        if (maxLength <= 0)
            throw new TypeError(`Invalid maxLength: ${maxLength}`);
        const total = req.originalLength ?? req.length; // req.data.length;
        const count = Math.ceil(total / maxLength) || 1;
        if (count === 1)
            return [req];
        const raw = Packet.raw(req);
        return [...new Array(count)].map((_, i) => {
            const start = i * maxLength;
            const length = Math.min(total - start, maxLength);
            const bufSize = Packet.baseSize + (req.io === IO.Write ? length : 0);
            const buffer = Buffer.alloc(bufSize);
            raw.copy(buffer, 0, 0, dataOffset);
            if (req.io === IO.Write) {
                req.data.copy(buffer, dataOffset, start, start + length);
            }
            const chunk = new Request(new Packet(buffer), req.broadcast, req.tag && `${req.tag}:${i}`);
            chunk.timeout = req.timeout;
            chunk.maxLength = maxLength;
            chunk.address += start;
            chunk.length = length;
            return chunk;
        });
    }
    static next() {
        Request.counter = (Request.counter + 1) % 256;
        return Request.counter;
    }
}
export const isNotBroadcast = (req) => !req.broadcast;
//# sourceMappingURL=Request.js.map