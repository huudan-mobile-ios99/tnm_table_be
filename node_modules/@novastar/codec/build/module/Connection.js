import debugFactory from 'debug';
import pump from 'pump';
import { TypedEmitter } from 'tiny-typed-emitter';
import ConnectionClosedError from './ConnectionClosedError';
import NovastarDecoder from './NovastarDecoder';
import NovastarEncoder from './NovastarEncoder';
import { ErrorType, Packet } from './Packet';
import Request, { isNotBroadcast } from './Request';
import ResponseError from './ResponseError';
import TimeoutError from './TimeoutError';
import { delay, notEmpty, series } from './helper';
const debug = debugFactory('novastar:connection');
/**
 * Wrapper for I/O stream using {@link Request} for out and {@link Packet} to in
 */
export default class Connection extends TypedEmitter {
    stream;
    /**
     * Default timeout for this connection
     */
    timeout = 1000;
    /**
     * Maximum default data length in single {@link Request} for this connection
     */
    maxLength = 256;
    ready = Promise.resolve();
    queue = [];
    encoder;
    decoder;
    connected = false;
    /**
     * Constructor
     * @param stream - wrapped I/O stream
     * @param open - automatically opens this connection, see {@link Connection.open}
     * @param timeout - default timeout for this connection
     */
    constructor(stream, open = true, timeout = 1000) {
        super();
        this.stream = stream;
        this.timeout = timeout;
        if (open)
            this.open();
    }
    /**
     * Returns true if the connection is ready for writing.
     */
    get isConnected() {
        return this.connected;
    }
    /**
     * Pipes streams (encoder->stream->decoder) together.
     * Emits {@link ConnectionEvents.open}
     */
    open() {
        if (this.connected)
            return;
        this.decoder = new NovastarDecoder();
        this.encoder = new NovastarEncoder();
        this.decoder.on('data', this.listener);
        pump(this.encoder, this.stream, this.decoder, (err) => {
            err && debug(`Error while pump: ${err.message}`);
            this.close();
        });
        this.connected = true;
        debug('open');
        this.emit('open');
    }
    /**
     * Detaches streams. Emits {@link ConnectionEvents.close}
     */
    close() {
        if (!this.connected)
            return;
        this.connected = false;
        this.decoder?.off('data', this.listener);
        this.stream.unpipe(this.decoder);
        this.encoder?.unpipe(this.stream);
        this.decoder?.destroy();
        this.decoder = undefined;
        this.encoder?.destroy();
        this.encoder = undefined;
        debug('close');
        this.emit('close');
    }
    send(req) {
        return new Promise((resolve, reject) => {
            this.ready = this.ready.finally().then(() => {
                const chunks = Request.makeChunks(req, this.getMaxLength(req));
                return series(chunks, chunk => this.sendImpl(chunk))
                    .then(results => {
                    const responses = results.filter(notEmpty);
                    if (responses.length === 0)
                        return resolve();
                    const [first] = responses;
                    if (responses.length === 1)
                        return resolve(first);
                    const srcRaw = Packet.raw(first);
                    const total = Buffer.concat(responses.map(res => res.data));
                    const result = new Packet(total.length + Packet.baseSize);
                    srcRaw.copy(Packet.raw(result));
                    // Object.entries(first.toJSON()).forEach(([name, value]) => {
                    //   if (name !== 'data') {
                    //     (result as Record<string, unknown>)[name] = value;
                    //   }
                    // });
                    result.length = total.length;
                    total.copy(result.data);
                    Packet.crc(result, true);
                    return resolve(result);
                })
                    .catch(reject);
            });
        });
    }
    /**
     * Sends a request, `length` of which does not exceed `maxLength`.
     * @param req
     * @returns In case of no response by timeout, returns null. Don't forget to check the `ack`
     * status of a response packet.
     */
    trySend(req) {
        return new Promise((resolve, reject) => {
            this.ready = this.ready.finally().then(() => this.sendImpl(req, true).then(resolve, reject));
        });
    }
    async sendImpl(req, skipErrors) {
        const { connected, encoder, } = this;
        if (!connected || !encoder)
            throw new ConnectionClosedError();
        const maxLength = this.getMaxLength(req);
        if (req.length > maxLength)
            throw new TypeError(`The request size is too large. Use "send" instead of "trySend", maxLength: ${maxLength}`);
        if (!encoder.write(req)) {
            await new Promise(resolve => {
                encoder.once('drain', resolve);
            });
        }
        if (isNotBroadcast(req)) {
            const res = await this.wait(req, skipErrors);
            if (!skipErrors && res && res.ack !== ErrorType.Succeeded) {
                const err = new ResponseError(res, req.tag);
                debug(err.message);
                throw err;
            }
            return res;
        }
        return delay(50);
    }
    wait(req, skipErrors) {
        return new Promise((resolve, reject) => {
            let timer;
            const complete = () => {
                global.clearTimeout(timer);
                this.queue = this.queue.filter(([request]) => req !== request);
            };
            const rejectTimeout = () => {
                complete();
                if (skipErrors)
                    return resolve(null);
                const err = new TimeoutError(req, req.tag);
                debug(err.message);
                return reject(err);
            };
            const resolveResponse = res => {
                complete();
                resolve(res);
            };
            timer = global.setTimeout(rejectTimeout, req.timeout ?? this.timeout);
            this.queue.push([req, resolveResponse]);
        });
    }
    listener = (res) => {
        const [, resolve] = this.queue.find(([req]) => req.serno === res.serno) ?? [];
        if (resolve)
            resolve(res);
        else if (res.source !== 255)
            debug(`Unknown package ${JSON.stringify(res)}`);
    };
    getMaxLength(req) {
        return req.maxLength || this.maxLength || 256;
    }
}
//# sourceMappingURL=Connection.js.map