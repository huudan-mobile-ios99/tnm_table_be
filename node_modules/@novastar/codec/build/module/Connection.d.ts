/// <reference types="node" />
import { Duplex } from 'stream';
import { TypedEmitter } from 'tiny-typed-emitter';
import { Packet } from './Packet';
import Request from './Request';
declare type ResolveResponse = (res: Packet) => void;
declare type WaitingRequest = [req: Request, resolve: ResolveResponse];
export interface ConnectionEvents {
    /**
     * The open event happens when the connection is opened and ready for writing
     */
    open(): void;
    /**
     * The close event is emitted when the connection is closed.
     */
    close(): void;
}
declare type Result<SkipErrors extends boolean = false> = SkipErrors extends false ? Packet : Packet | null;
declare type Response<Broadcast extends boolean, SkipErrors extends boolean = false> = Promise<Broadcast extends false ? Result<SkipErrors> : void>;
/**
 * Wrapper for I/O stream using {@link Request} for out and {@link Packet} to in
 */
export default class Connection<S extends Duplex> extends TypedEmitter<ConnectionEvents> {
    readonly stream: S;
    /**
     * Default timeout for this connection
     */
    timeout: number;
    /**
     * Maximum default data length in single {@link Request} for this connection
     */
    maxLength: number;
    protected ready: Promise<void>;
    protected queue: WaitingRequest[];
    private encoder;
    private decoder;
    private connected;
    /**
     * Constructor
     * @param stream - wrapped I/O stream
     * @param open - automatically opens this connection, see {@link Connection.open}
     * @param timeout - default timeout for this connection
     */
    constructor(stream: S, open?: boolean, timeout?: number);
    /**
     * Returns true if the connection is ready for writing.
     */
    get isConnected(): boolean;
    /**
     * Pipes streams (encoder->stream->decoder) together.
     * Emits {@link ConnectionEvents.open}
     */
    open(): void;
    /**
     * Detaches streams. Emits {@link ConnectionEvents.close}
     */
    close(): void;
    /**
     * Decodes the request and sends the raw data to the stream after the previous operation
     * completes, If the request `length` exceeds the `maxLength`, the request will be split into
     * multiple requests and responses will be composed.
     * @param req - request
     * @returns If the request is not broadcast, then a successful response to the request is
     * returned. If the response status is not successful or a timeout occurs, an exception is thrown.
     * @see TimeoutError
     * @see ResponseError
     */
    send<Broadcast extends boolean>(req: Request<Broadcast>): Response<Broadcast>;
    /**
     * Sends a request, `length` of which does not exceed `maxLength`.
     * @param req
     * @returns In case of no response by timeout, returns null. Don't forget to check the `ack`
     * status of a response packet.
     */
    trySend(req: Request): Promise<Packet | null>;
    protected sendImpl<Broadcast extends boolean, SkipErrors extends boolean = false>(req: Request<Broadcast>, skipError?: SkipErrors): Response<Broadcast, SkipErrors>;
    protected wait<SkipErrors extends boolean = false>(req: Request, skipErrors?: SkipErrors): Promise<Result<SkipErrors>>;
    protected listener: (res: Packet) => void;
    protected getMaxLength(req: Request<boolean>): number;
}
export {};
