"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.notEmpty = exports.series = exports.delay = exports.printBuffer = void 0;
/**
 * Split array/buffer/string into chunks
 * @param array - source array
 * @param len - chunk size
 */
function chunkArray(array, len) {
    const ret = [];
    const size = Math.ceil(array.length / len);
    ret.length = size;
    let offset;
    for (let i = 0; i < size; i += 1) {
        offset = i * len;
        ret[i] = array.slice(offset, offset + len);
    }
    return ret;
}
/**
 * Buffer formatting
 * @param buffer
 */
function printBuffer(buffer) {
    return chunkArray(chunkArray(buffer.toString('hex'), 2), 16)
        .map(chunk => chunk.join('-'))
        .join('=');
}
exports.printBuffer = printBuffer;
/**
 * Create a promise which resolves after the specified milliseconds.
 * @param ms
 */
const delay = (ms) => new Promise(resolve => {
    setTimeout(resolve, ms);
});
exports.delay = delay;
/**
 * Performs an asynchronous operation sequentially on all elements of an array
 * @param array
 * @param action
 */
function series(array, action) {
    return array.reduce((acc, item, index) => acc.then(async (items) => {
        const result = await action(item, index, array, items);
        return [...items, result];
    }), Promise.resolve([]));
}
exports.series = series;
/**
 * 'Not Empty' type guard
 * @param value
 */
function notEmpty(value) {
    return (value !== undefined && value !== null && (typeof value !== 'number' || !Number.isNaN(value)));
}
exports.notEmpty = notEmpty;
//# sourceMappingURL=helper.js.map