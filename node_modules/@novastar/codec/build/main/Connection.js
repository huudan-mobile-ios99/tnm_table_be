"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const pump_1 = __importDefault(require("pump"));
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const ConnectionClosedError_1 = __importDefault(require("./ConnectionClosedError"));
const NovastarDecoder_1 = __importDefault(require("./NovastarDecoder"));
const NovastarEncoder_1 = __importDefault(require("./NovastarEncoder"));
const Packet_1 = require("./Packet");
const Request_1 = __importStar(require("./Request"));
const ResponseError_1 = __importDefault(require("./ResponseError"));
const TimeoutError_1 = __importDefault(require("./TimeoutError"));
const helper_1 = require("./helper");
const debug = (0, debug_1.default)('novastar:connection');
/**
 * Wrapper for I/O stream using {@link Request} for out and {@link Packet} to in
 */
class Connection extends tiny_typed_emitter_1.TypedEmitter {
    /**
     * Constructor
     * @param stream - wrapped I/O stream
     * @param open - automatically opens this connection, see {@link Connection.open}
     * @param timeout - default timeout for this connection
     */
    constructor(stream, open = true, timeout = 1000) {
        super();
        this.stream = stream;
        /**
         * Default timeout for this connection
         */
        this.timeout = 1000;
        /**
         * Maximum default data length in single {@link Request} for this connection
         */
        this.maxLength = 256;
        this.ready = Promise.resolve();
        this.queue = [];
        this.connected = false;
        this.listener = (res) => {
            const [, resolve] = this.queue.find(([req]) => req.serno === res.serno) ?? [];
            if (resolve)
                resolve(res);
            else if (res.source !== 255)
                debug(`Unknown package ${JSON.stringify(res)}`);
        };
        this.timeout = timeout;
        if (open)
            this.open();
    }
    /**
     * Returns true if the connection is ready for writing.
     */
    get isConnected() {
        return this.connected;
    }
    /**
     * Pipes streams (encoder->stream->decoder) together.
     * Emits {@link ConnectionEvents.open}
     */
    open() {
        if (this.connected)
            return;
        this.decoder = new NovastarDecoder_1.default();
        this.encoder = new NovastarEncoder_1.default();
        this.decoder.on('data', this.listener);
        (0, pump_1.default)(this.encoder, this.stream, this.decoder, (err) => {
            err && debug(`Error while pump: ${err.message}`);
            this.close();
        });
        this.connected = true;
        debug('open');
        this.emit('open');
    }
    /**
     * Detaches streams. Emits {@link ConnectionEvents.close}
     */
    close() {
        if (!this.connected)
            return;
        this.connected = false;
        this.decoder?.off('data', this.listener);
        this.stream.unpipe(this.decoder);
        this.encoder?.unpipe(this.stream);
        this.decoder?.destroy();
        this.decoder = undefined;
        this.encoder?.destroy();
        this.encoder = undefined;
        debug('close');
        this.emit('close');
    }
    send(req) {
        return new Promise((resolve, reject) => {
            this.ready = this.ready.finally().then(() => {
                const chunks = Request_1.default.makeChunks(req, this.getMaxLength(req));
                return (0, helper_1.series)(chunks, chunk => this.sendImpl(chunk))
                    .then(results => {
                    const responses = results.filter(helper_1.notEmpty);
                    if (responses.length === 0)
                        return resolve();
                    const [first] = responses;
                    if (responses.length === 1)
                        return resolve(first);
                    const srcRaw = Packet_1.Packet.raw(first);
                    const total = Buffer.concat(responses.map(res => res.data));
                    const result = new Packet_1.Packet(total.length + Packet_1.Packet.baseSize);
                    srcRaw.copy(Packet_1.Packet.raw(result));
                    // Object.entries(first.toJSON()).forEach(([name, value]) => {
                    //   if (name !== 'data') {
                    //     (result as Record<string, unknown>)[name] = value;
                    //   }
                    // });
                    result.length = total.length;
                    total.copy(result.data);
                    Packet_1.Packet.crc(result, true);
                    return resolve(result);
                })
                    .catch(reject);
            });
        });
    }
    /**
     * Sends a request, `length` of which does not exceed `maxLength`.
     * @param req
     * @returns In case of no response by timeout, returns null. Don't forget to check the `ack`
     * status of a response packet.
     */
    trySend(req) {
        return new Promise((resolve, reject) => {
            this.ready = this.ready.finally().then(() => this.sendImpl(req, true).then(resolve, reject));
        });
    }
    async sendImpl(req, skipErrors) {
        const { connected, encoder, } = this;
        if (!connected || !encoder)
            throw new ConnectionClosedError_1.default();
        const maxLength = this.getMaxLength(req);
        if (req.length > maxLength)
            throw new TypeError(`The request size is too large. Use "send" instead of "trySend", maxLength: ${maxLength}`);
        if (!encoder.write(req)) {
            await new Promise(resolve => {
                encoder.once('drain', resolve);
            });
        }
        if ((0, Request_1.isNotBroadcast)(req)) {
            const res = await this.wait(req, skipErrors);
            if (!skipErrors && res && res.ack !== Packet_1.ErrorType.Succeeded) {
                const err = new ResponseError_1.default(res, req.tag);
                debug(err.message);
                throw err;
            }
            return res;
        }
        return (0, helper_1.delay)(50);
    }
    wait(req, skipErrors) {
        return new Promise((resolve, reject) => {
            let timer;
            const complete = () => {
                global.clearTimeout(timer);
                this.queue = this.queue.filter(([request]) => req !== request);
            };
            const rejectTimeout = () => {
                complete();
                if (skipErrors)
                    return resolve(null);
                const err = new TimeoutError_1.default(req, req.tag);
                debug(err.message);
                return reject(err);
            };
            const resolveResponse = res => {
                complete();
                resolve(res);
            };
            timer = global.setTimeout(rejectTimeout, req.timeout ?? this.timeout);
            this.queue.push([req, resolveResponse]);
        });
    }
    getMaxLength(req) {
        return req.maxLength || this.maxLength || 256;
    }
}
exports.default = Connection;
//# sourceMappingURL=Connection.js.map