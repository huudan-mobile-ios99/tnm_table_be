"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNotBroadcast = void 0;
const Packet_1 = require("./Packet");
const isLikeNumberArray = (value) => Buffer.isBuffer(value) ||
    (Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number'));
const createArgs = (param) => {
    if ((0, Packet_1.isPacket)(param))
        return [Packet_1.Packet.raw(param), true];
    const raw = Buffer.alloc(Packet_1.Packet.baseSize + (isLikeNumberArray(param) ? param.length : 0));
    return [raw, undefined];
};
const dataOffset = Packet_1.Packet.getOffsetOf('data');
/**
 * Custom request prepared for sending to Novastar devices
 */
class Request extends Packet_1.Packet {
    constructor(param, param2, param3) {
        super(...createArgs(param));
        const broadcast = typeof param2 === 'boolean' ? param2 : undefined;
        this.tag = typeof param2 === 'string' ? param2 : param3;
        if (!(0, Packet_1.isPacket)(param)) {
            this.head = Packet_1.REQUEST;
            this.source = Packet_1.COMPUTER;
            this.broadcast = broadcast;
            if (isLikeNumberArray(param)) {
                this.io = Packet_1.IO.Write;
                Buffer.from(param).copy(this.data);
                this.length = param.length;
                this.originalLength = param.length;
            }
            else {
                this.io = Packet_1.IO.Read;
                this.length = param;
                this.originalLength = param;
            }
        }
        else if (param instanceof Request) {
            this.broadcast = param.broadcast;
            this.timeout = param.timeout;
            this.maxLength = param.maxLength;
            this.originalLength = param.originalLength;
            this.tag = param.tag;
        }
        this.serno = Request.next();
    }
    /**
     * Split the original request into chunks with the specified maximum data length
     * @param req - original request
     * @param maxLength - maximum data length
     * @returns - chunks
     */
    static makeChunks(req, maxLength = 256) {
        if (maxLength <= 0)
            throw new TypeError(`Invalid maxLength: ${maxLength}`);
        const total = req.originalLength ?? req.length; // req.data.length;
        const count = Math.ceil(total / maxLength) || 1;
        if (count === 1)
            return [req];
        const raw = Packet_1.Packet.raw(req);
        return [...new Array(count)].map((_, i) => {
            const start = i * maxLength;
            const length = Math.min(total - start, maxLength);
            const bufSize = Packet_1.Packet.baseSize + (req.io === Packet_1.IO.Write ? length : 0);
            const buffer = Buffer.alloc(bufSize);
            raw.copy(buffer, 0, 0, dataOffset);
            if (req.io === Packet_1.IO.Write) {
                req.data.copy(buffer, dataOffset, start, start + length);
            }
            const chunk = new Request(new Packet_1.Packet(buffer), req.broadcast, req.tag && `${req.tag}:${i}`);
            chunk.timeout = req.timeout;
            chunk.maxLength = maxLength;
            chunk.address += start;
            chunk.length = length;
            return chunk;
        });
    }
    static next() {
        Request.counter = (Request.counter + 1) % 256;
        return Request.counter;
    }
}
exports.default = Request;
Request.counter = 0;
const isNotBroadcast = (req) => !req.broadcast;
exports.isNotBroadcast = isNotBroadcast;
//# sourceMappingURL=Request.js.map