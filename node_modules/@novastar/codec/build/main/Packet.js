"use strict";
/* eslint-disable @typescript-eslint/no-empty-interface */
// noinspection JSUnusedGlobalSymbols
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPacket = exports.Packet = exports.COMPUTER = exports.RESPONSE = exports.REQUEST = exports.ErrorType = exports.IO = exports.DeviceType = void 0;
const typed_struct_1 = __importStar(require("typed-struct"));
/**
 * Destination device type
 */
var DeviceType;
(function (DeviceType) {
    /**
     * Devices connected to the COM/USB port
     */
    DeviceType[DeviceType["SendingCard"] = 0] = "SendingCard";
    DeviceType[DeviceType["ReceivingCard"] = 1] = "ReceivingCard";
    DeviceType[DeviceType["FunctionCard"] = 2] = "FunctionCard";
})(DeviceType = exports.DeviceType || (exports.DeviceType = {}));
/**
 * I/O operation type
 */
var IO;
(function (IO) {
    IO[IO["Read"] = 0] = "Read";
    IO[IO["Write"] = 1] = "Write";
})(IO = exports.IO || (exports.IO = {}));
/**
 * Operation result code
 */
var ErrorType;
(function (ErrorType) {
    ErrorType[ErrorType["Succeeded"] = 0] = "Succeeded";
    ErrorType[ErrorType["Timeout"] = 1] = "Timeout";
    ErrorType[ErrorType["RequestError"] = 2] = "RequestError";
    ErrorType[ErrorType["AcknowledgeError"] = 3] = "AcknowledgeError";
    ErrorType[ErrorType["InvalidCommand"] = 4] = "InvalidCommand";
})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));
/*
export enum DisplayMode {
  Video,
  Red = 2,
  Green,
  Blue,
  White,
  HorizonLine,
  VerticalLine,
  InclineLine,
  Grayscale,
  Loop,
}

export enum Calibration {
  Color,
  Brightness,
}
*/
/**
 * Request header
 */
exports.REQUEST = 0xaa55;
/**
 * Response header
 */
exports.RESPONSE = 0x55aa;
/**
 * For a request, this is the source (sender) address; for a response, the destination address
 */
exports.COMPUTER = 0xfe;
/**
 * @function Constructor for creating and processing binary packages used when communicating with novastar devices
 * @see {@link Packet}
 * @see {@link https://sarakusha.github.io/typed-struct/interfaces/StructConstructor.html}
 */
exports.Packet = new typed_struct_1.default('Packet')
    .UInt16LE('head', (0, typed_struct_1.typed)())
    .UInt8('ack', (0, typed_struct_1.typed)())
    .UInt8('serno')
    .UInt8('source')
    .UInt8('destination')
    .UInt8('deviceType', (0, typed_struct_1.typed)())
    .UInt8('port')
    .UInt16LE('rcvIndex')
    .UInt8('io', (0, typed_struct_1.typed)())
    .seek(1)
    .UInt32LE('address')
    .UInt16LE('length')
    .Buffer('data')
    .CRC16LE('crc', {
    calc: raw => raw.reduce((crc, val) => (crc + val) % 0x10000, 0x5555),
    start: 2,
})
    .compile();
/**
 * [[Packet]] type guard
 * @param packet
 */
function isPacket(packet) {
    return packet instanceof exports.Packet;
}
exports.isPacket = isPacket;
//# sourceMappingURL=Packet.js.map